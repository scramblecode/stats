<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scramble Stats</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/x-icon" href="assets/img/ico.ico">
    <!-- Include Open Sans from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap"
      rel="stylesheet"
    />
</head>
<body>
    <h1 class="outside-text">Battle Stats</h1>
    
    <div id="content">
        <p>Loading match data...</p>
    </div>

    <script>

const facIcons = ["flag_swadia","flag_vaegir","flag_khergit","flag_nord","flag_rhodok","flag_sarranid"]
const factions = ["Kingdom of Swadia", "Kingdom of Vaegirs", "Khergit Khanate", "Kingdom of Nords", "Kingdom of Rhodoks", "Sarranid Sultanate"]
const infClasses = [
  "Swadian Infantry",
  "Vaegir Spearman",
  "Khergit Infantry",
  "Nord Huscarl",
  "Rhodok Sergeant",
  "Sarranid Footman",
]
const arcClasses = [
  "Swadian Crossbowman",
  "Vaegir Archer",
  "Khergit Horse Archer",
  "Nord Archer",
  "Rhodok Crossbowman",
  "Sarranid Archer",
]
const cavClasses = [
  "Swadian Man at Arms",
  "Vaegir Horseman",
  "Khergit Lancer",
  "Nord Scout",
  "Rhodok Horseman",
  "Sarranid Mamluke",
]

const openMaps = [
  "Ruins",
  "Steppe Valley",
  "Cheese Cove",
  "Field by the River",
  "Desert Town",
  "Castellum",
  "Frosthaven",
  "Reveran Village",
  "River Village",
  "Creekside",
  "Waterfall",
];
const closedMaps = [
  "Khergit Village",
  "Nord Town",
  "Twin Fort",
  "Fort of Honour",
  "Naval Outpost",
  "San'di'boush",
  "Dreiecksdorf",
  "Verloren",
  "Legacy Town",
  "Mountain Fortress",
  "Winterburg",
  "Beairteas",
  "Aldea Dumar",
];

const allMaps = [...openMaps, ...closedMaps];

//sets headers as constants and change on small screen width
const fullStats = ["Player", "Kills", "Deaths", "Assists", "DMG", "TKs", "TDMG"];
const smolStats = ["Plyr", "K", "D", "A", "Dm", "TK", "TDm"];
const colNames = [...fullStats];
if (window.innerWidth < window.innerHeight) {
        for (let i = 0; i < colNames.length; i++) {
            colNames[i] = smolStats[i]; // Replace values
        }
      }

function adjustTableLayout() {
    const tablesContainer = document.getElementById("tables-container");
    if(tablesContainer === null) return;
    // console.log("Adjust", colNames, tablesContainer.children[1].children[1].children)
    const team1Table = tablesContainer.children[0]; // First table
    const team2Table = tablesContainer.children[1]; // Second table

    // Calculate combined table widths
    const totalWidth = team1Table.offsetWidth + team2Table.offsetWidth;

    // Get screen dimensions
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    // Stack vertically if tables are too wide for the screen or screen is portrait
    if (totalWidth > windowWidth || windowWidth < windowHeight) {

    // Shorten player names if longer than 20 characters
    // for (let i = 0; i < playerNames.length; i++) {
    //     if (playerNames[i].length > 20) {
    //         const aliasArray = playerAliases[i]; // Array of aliases for the current player
    //         const shortestAlias = aliasArray.reduce((shortest, current) => 
    //             current.length < shortest.length ? current : shortest, aliasArray[0]
    //         );
    //         playerNames[i] = shortestAlias; // Replace with the shortest alias
    //     }
    // }
    
        tablesContainer.style.flexDirection = "column"; // Stack vertically
        tablesContainer.style.alignItems = "left"; // Center the tables
        tablesContainer.style.margin = "0"; // Center the tables
        for (let i = 0; i < colNames.length; i++) {
            colNames[i] = smolStats[i]; // Replace values
        }
    } else {
        tablesContainer.style.flexDirection = "row"; // Side-by-side layout
        tablesContainer.style.alignItems = "flex-start"; // Default alignment
        for (let i = 0; i < colNames.length; i++) {
            colNames[i] = fullStats[i]; // Replace values
        }
    }
}

// Add event listener to handle screen resize
window.addEventListener("resize", adjustTableLayout);



function renderPlayerDetails(playerID) {
    const contentDiv = document.getElementById("content");
    contentDiv.classList.remove("bracket");
    contentDiv.classList.remove("landing");
    contentDiv.classList.add("match-detail");
    contentDiv.innerHTML = ""; // Clear previous content

    renderTabBar(contentDiv, "players");
    const tabContentContainer = document.createElement("div");
    tabContentContainer.id = "tab-content";
    tabContentContainer.style.marginTop = "20px";

    const nameToIdMap = new Map();
        playerIds.forEach((id, index) => {
          if (id === 0 ) return;
            playerNames[index].forEach(name => {
                nameToIdMap.set(name.toLowerCase(), id); // Use lowercase for case-insensitive mapping
            });
        });

    const playersContainer = document.createElement("h1")
    playersContainer.textContent = `${playerNames[playerIds.indexOf(playerID)][0]}`;

    tabContentContainer.appendChild(playersContainer);
    
        // Collect associated names for the given playerID
        const associatedNames = [];
    nameToIdMap.forEach((id, name) => {
        if (id === playerID) {
            associatedNames.push(name);
        }
    });

    // Calculate Kills and Deaths
    let totalKills = 0;
    let totalDeaths = 0;

    // Assuming `rounds` is an array of round data that contains kills and deaths
    matches.forEach((match) => {
      match.rounds.forEach((round) => {
        // Count kills for all associated names
        round.kills.forEach((killerName) => {
            if (associatedNames.includes(killerName.toLowerCase())) {
                totalKills++;
            }
        });

        // Count deaths for all associated names
        round.deaths.forEach((deathName) => {
            if (associatedNames.includes(deathName.toLowerCase())) {
                totalDeaths++;
            }
        });
      });

    })

    // Display Kills and Deaths
    const statsContainer = document.createElement("div");
    statsContainer.className = "player-stats";

    const killsDiv = document.createElement("div");
    killsDiv.textContent = `Total Kills: ${totalKills}`;
    statsContainer.appendChild(killsDiv);

    const deathsDiv = document.createElement("div");
    deathsDiv.textContent = `Total Deaths: ${totalDeaths}`;
    statsContainer.appendChild(deathsDiv);

    tabContentContainer.appendChild(statsContainer);
// Prepare to collect kill/death stats
    const killedByCounts = new Map();
    const killedCounts = new Map();
    const teamkilledByCounts = new Map();
    const teamkilledCounts = new Map();

    matches.forEach((match) => {
        match.rounds.forEach((round) => {
            let tkid = 0; // Counter for teamkills
            let tkkilled = 0; // Counter for teamkilled

            round.deaths.forEach((victimName, index) => {
                // Adjust for teamkills
                while (round.teamkilled[tkkilled] === round.deaths[index]) {
                    tkkilled++;
                }

                const killerName = round.kills[index - tkkilled]?.toLowerCase(); // Get associated killer
                const killerID = nameToIdMap.get(killerName); // Map killer name to ID
                const victimID = nameToIdMap.get(victimName.toLowerCase()); // Map victim name to ID

                if (associatedNames.includes(killerName)) {
                    // Player killed someone
                    if (victimID) {
                        const victimCount = killedCounts.get(victimID) || 0;
                        killedCounts.set(victimID, victimCount + 1);
                    }
                }

                if (associatedNames.includes(victimName.toLowerCase())) {
                    // Player was killed by someone
                    if (killerID) {
                        const killerCount = killedByCounts.get(killerID) || 0;
                        killedByCounts.set(killerID, killerCount + 1);
                    }
                }
            });

            round.kills.forEach((killerName, index) => {
                // Adjust for teamkills
                while (round.teamkills[tkid] === round.kills[index]) {
                    tkid++;
                }

                const victimName = round.deaths[index + tkid]?.toLowerCase(); // Get associated victim
                const killerID = nameToIdMap.get(killerName.toLowerCase()); // Map killer name to ID
                const victimID = nameToIdMap.get(victimName); // Map victim name to ID

                if (associatedNames.includes(victimName)) {
                    // Player killed someone
                    if (victimID) {
                        const victimCount = killedCounts.get(victimID) || 0;
                        killedCounts.set(victimID, victimCount + 1);
                    }
                }

                if (associatedNames.includes(killerName.toLowerCase())) {
                    // Player was killed by someone
                    if (killerID) {
                        const killerCount = killedByCounts.get(killerID) || 0;
                        killedByCounts.set(killerID, killerCount + 1);
                    }
                }
            });

            // Handle teamkills/teamkilledBy
            round.teamkilled.forEach((victimName, tkIndex) => {
                const killerName = round.teamkills[tkIndex]?.toLowerCase(); // Associated teamkiller
                const teamkillerID = nameToIdMap.get(killerName); // Map killer name to ID
                const teamkilledID = nameToIdMap.get(victimName.toLowerCase()); // Map victim name to ID

                if (associatedNames.includes(killerName)) {
                    // Player teamkilled someone
                    if (teamkilledID) {
                        const count = teamkilledCounts.get(teamkilledID) || 0;
                        teamkilledCounts.set(teamkilledID, count + 1);
                    }
                }

                if (associatedNames.includes(victimName.toLowerCase())) {
                    // Player was teamkilled by someone
                    if (teamkillerID) {
                        const count = teamkilledByCounts.get(teamkillerID) || 0;
                        teamkilledByCounts.set(teamkillerID, count + 1);
                    }
                }
            });
        });
    });
// Combine killed and killedBy stats into one list for display
    const playerStats = new Map();
    nameToIdMap.forEach((id, name) => {
        if (!playerStats.has(id)) {
            playerStats.set(id, { name: name, killed: 0, killedBy: 0, id: id, teamkilled: 0, teamkilledBy: 0 });
        }
    });

    killedCounts.forEach((count, id) => {
        if (playerStats.has(id)) {
            playerStats.get(id).killed = count;
        }
    });

    killedByCounts.forEach((count, id) => {
        if (playerStats.has(id)) {
            playerStats.get(id).killedBy = count;
        }
    });


    teamkilledCounts.forEach((count, id) => {
        if (playerStats.has(id)) {
            playerStats.get(id).teamkilled = count;
        }
    });

    teamkilledByCounts.forEach((count, id) => {
        if (playerStats.has(id)) {
            playerStats.get(id).teamkilledBy = count;
        }
    });
    const filteredStats = Array.from(playerStats.values()).filter(
      (stat) =>
        stat.killed > 0 ||
        stat.killedBy > 0 ||
        stat.teamkilled > 0 ||
        stat.teamkilledBy > 0
    );
    // Sort the stats by highest count of Killed or Killed By
    const sortedStats = Array.from(filteredStats.values()).sort(
        (a, b) => b.killedBy - (a.killedBy)
    );

    // Create the table
    const statsTable = document.createElement("table");
    statsTable.style.width = "100%";
    statsTable.style.borderCollapse = "collapse";

    const headerRow = document.createElement("tr");
    ["Player", "Killed", "Killed By", "Teamkilled", "Teamkilled By"].forEach((header) => {
        const th = document.createElement("th");
        th.textContent = header;
        th.style.border = "1px solid #ddd";
        th.style.padding = "10px";
        th.style.textAlign = "center";
        //th.style.backgroundColor = "#f4f4f4";
        headerRow.appendChild(th);
    });
    statsTable.appendChild(headerRow);

    // Add rows for each player
    sortedStats.forEach((stat) => {
      if (associatedNames.includes(stat.name)) return;
        const row = document.createElement("tr");

        const playerCell = document.createElement("td");
        playerCell.textContent = playerNames[playerIds.indexOf(stat.id)][0];
        playerCell.style.border = "1px solid #ddd";
        playerCell.style.padding = "10px";
        playerCell.style.textAlign = "center";

        const killedCell = document.createElement("td");
        killedCell.textContent = stat.killed;
        killedCell.style.border = "1px solid #ddd";
        killedCell.style.padding = "10px";
        killedCell.style.textAlign = "center";

        const killedByCell = document.createElement("td");
        killedByCell.textContent = stat.killedBy;
        killedByCell.style.border = "1px solid #ddd";
        killedByCell.style.padding = "10px";
        killedByCell.style.textAlign = "center";

        const teamkilledCell = document.createElement("td");
        teamkilledCell.textContent = stat.teamkilled;
        teamkilledCell.style.border = "1px solid #ddd";
        teamkilledCell.style.padding = "10px";
        teamkilledCell.style.textAlign = "center";

        const teamkilledByCell = document.createElement("td");
        teamkilledByCell.textContent = stat.teamkilledBy;
        teamkilledByCell.style.border = "1px solid #ddd";
        teamkilledByCell.style.padding = "10px";
        teamkilledByCell.style.textAlign = "center";

        row.appendChild(playerCell);
        row.appendChild(killedCell);
        row.appendChild(killedByCell);
        row.appendChild(teamkilledCell);
        row.appendChild(teamkilledByCell);

        statsTable.appendChild(row);
    });

    tabContentContainer.appendChild(statsTable);
    contentDiv.appendChild(tabContentContainer);
}


//externally calculate winning team based on Result string
//input: result, output: 0, 1, -1(draw)
function getWinner(result){
  
  let winner = -1;
    if (result.includes("Team 2 win")) {
      if (result.includes("flag"))
        {winner = 1} else {winner = 0};
    } else if (result.includes("Team 1 win")) {
      if (result.includes("flag"))
        {winner = 0} else {winner = 1};
    }
    return winner;
}

  // Helper: Compute player stats from a data source.
  // 'data' can be an array of rounds (for an entire match) or a single round.
  // When given multiple rounds, stats will be aggregated.
  function getPlayerStats(rounds) {
    const stats = {}; // player name -> stats object

    // 'rounds' can be an array; if it is not, treat it as a single round.
    if (!Array.isArray(rounds)) {
      rounds = [rounds];
    }

    rounds.forEach((round, roundID) => {
      round.players.forEach((player, index) => {
        if (!stats[player]) {
          stats[player] = {
            team: round.teams[index],
            classes: [],
            kills: 0,
            deaths: 0,
            assists: 0,
            dmg: 0,
            teamkills: 0,
            tdmg: 0,
            wins: 0,
          };
        }
        // For kills and teamkills, count the number of appearances in the roundâ€™s arrays.
        stats[player].kills += round.kills.filter(k => k === player).length;
        stats[player].deaths += round.deaths.filter(d => d === player).length;
        stats[player].assists += round.assists[index] || 0;
        stats[player].dmg += round.dmg[index] || 0;
        stats[player].teamkills += round.teamkills.filter(tk => tk === player).length;
        stats[player].tdmg += round.tdmg[index] || 0;
        stats[player].wins += getWinner(round.result) === stats[player].team ? 1 : 0;
        stats[player].classes.push(round.classes[index])
      });
    });
    return stats;
  }

  // Helper: Given an object mapping player names to stats,
  // split them into entries for players on team 0 and team 1,
  // then sort each by kills descending.
  function splitAndSortByTeam(playerStats) {
    const team0 = [];
    const team1 = [];
    Object.entries(playerStats).forEach(([player, stats]) => {
      if (stats.team === 0) {
        team0.push([player, stats]);
      } else if (stats.team === 1) {
        team1.push([player, stats]);
      }
    });
    team0.sort((a, b) => b[1].kills - a[1].kills);
    team1.sort((a, b) => b[1].kills - a[1].kills);
    return { team0, team1 };
  }

  // Helper: Generate a team's stats table given sorted data and a heading (faction name).
  function generateTeamTableCommon(teamData, heading, sh) {
    const teamDiv = document.createElement("div");
    teamDiv.style.flex = "1";
    teamDiv.style.minWidth = "0";

    const headerDiv = document.createElement("div");
    headerDiv.className = "team-header";
    headerDiv.style.display = "flex";
    headerDiv.style.justifyContent = "space-between";
    headerDiv.style.alignItems = "center";
    headerDiv.style.marginBottom = "10px";

    if (sh==1) {
      const headingElem = document.createElement("h1");
      headingElem.textContent = heading;
      headingElem.style.margin = "0";
      headerDiv.appendChild(headingElem);
    }
    // (Optionally, you could add a score display here if available.)
    teamDiv.appendChild(headerDiv);

    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.borderCollapse = "collapse";

    const headerRow = document.createElement("tr");
    // Column headers: "Player", "Kills", "Deaths", "Assists", "Damage", "Team Kills", "Team Damage"
    colNames.forEach((colHeader, idx) => {
      const th = document.createElement("th");
      th.textContent = colHeader;
      // For the first column, left-align; others we center except we override in inline style later.
      th.style.textAlign = idx === 0 ? "left" : "right";
      th.style.borderBottom = "2px solid #ddd";
      th.style.padding = "5px";
      headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    // Add rows for each player in this team
    teamData.forEach(([player, stats]) => {
      const row = document.createElement("tr");
      [player, stats.kills, stats.deaths, stats.assists, stats.dmg, stats.teamkills, stats.tdmg].forEach((value, idx) => {
        const td = document.createElement("td");
        td.setAttribute("data-player", player);
        td.textContent = value;
        // First column (names) left-aligned; index 4 (Damage) and 6 (Team Damage) right-aligned;
        // all others center-aligned.
        if (idx === 0) {
          td.style.textAlign = "left";
          td.style.whiteSpace = "nowrap";
          td.style.overflow = "visible";
          
          const dead = !Number.isInteger(stats.deaths) && stats.deaths.includes("+1");
          const flip = stats.team;
          // Count occurrences for each class
          const infCount = countClassUsage(infClasses, stats.classes);
          const cavCount = countClassUsage(cavClasses, stats.classes);
          const arcCount = countClassUsage(arcClasses, stats.classes);
          //console.log(value, infCount, cavCount, arcCount)
          
          // Infantry Icon with Count
          if (infCount > 0) {
            const infContainer = document.createElement("div");
            infContainer.style.position = "relative";
            infContainer.style.display = "inline-block";
            infContainer.style.marginLeft = "8px";

            const infclass = document.createElement("img");
            infclass.src = "assets/img/class_inf.png";
            infclass.alt = "inf";
            if (flip) infclass.style.transform = "scaleX(-1)";
            //infclass.style.filter = `grayscale(${+dead})`;
            infclass.height = infclass.naturalHeight * 0.35;
            infclass.onload = () => {
              infclass.height = infclass.naturalHeight * 0.35;
            }
            infclass.style.display = "block";

            // const infCountSpan = document.createElement("span");
            // infCountSpan.textContent = infCount;
            // infCountSpan.style.position = "absolute";
            // infCountSpan.style.bottom = "-2px"; // Slightly below the image
            // infCountSpan.style.left = "60%";
            // infCountSpan.style.transform = "translateX(-50%)";
            // infCountSpan.style.fontSize = "10px"; // Small font
            // infCountSpan.style.color = "#d1d1d1";

            infContainer.appendChild(infclass);
            // infContainer.appendChild(infCountSpan);
            td.appendChild(infContainer);
          }

          // Cavalry Icon with Count
          if (cavCount > 0) {
            const cavContainer = document.createElement("div");
            cavContainer.style.position = "relative";
            cavContainer.style.display = "inline-block";
            cavContainer.style.marginLeft = "8px";

            const cavclass = document.createElement("img");
            cavclass.src = "assets/img/class_cav.png";
            cavclass.alt = "cav";
            if (flip) cavclass.style.transform = "scaleX(-1)";
            //cavclass.style.filter = `grayscale(${+dead})`;
            cavclass.height = cavclass.naturalHeight * 0.35;
            cavclass.onload = () => {
              cavclass.height = cavclass.naturalHeight * 0.35;
            }
            cavclass.style.display = "block";

            // const cavCountSpan = document.createElement("span");
            // cavCountSpan.textContent = cavCount;
            // cavCountSpan.style.position = "absolute";
            // cavCountSpan.style.bottom = "-2px"; // Slightly below the image
            // cavCountSpan.style.left = "60%";
            // cavCountSpan.style.transform = "translateX(-50%)";
            // cavCountSpan.style.fontSize = "10px"; // Small font
            // cavCountSpan.style.color = "#d1d1d1";

            cavContainer.appendChild(cavclass);
            // cavContainer.appendChild(cavCountSpan);
            td.appendChild(cavContainer);
          }

          // Archer Icon with Count
          if (arcCount > 0) {
            const arcContainer = document.createElement("div");
            arcContainer.style.position = "relative";
            arcContainer.style.display = "inline-block";
            arcContainer.style.marginLeft = "8px";

            const arcclass = document.createElement("img");
            arcclass.src = "assets/img/class_arc.png";
            arcclass.alt = "arc";
            if (flip) arcclass.style.transform = "scaleX(-1)";
            //arcclass.style.filter = `grayscale(${+dead})`;
            arcclass.height = arcclass.naturalHeight * 0.35;
            arcclass.onload = () => {
              arcclass.height = arcclass.naturalHeight * 0.35;
            }
            arcclass.style.display = "block";

            // const arcCountSpan = document.createElement("span");
            // arcCountSpan.textContent = arcCount;
            // arcCountSpan.style.position = "absolute";
            // arcCountSpan.style.bottom = "-2px"; // Slightly below the image
            // arcCountSpan.style.left = "60%";
            // arcCountSpan.style.transform = "translateX(-50%)";
            // arcCountSpan.style.fontSize = "10px"; // Small font
            // arcCountSpan.style.color = "#d1d1d1";

            arcContainer.appendChild(arcclass);
            // arcContainer.appendChild(arcCountSpan);
            td.appendChild(arcContainer);
          }
        // } else if (idx === 4 || idx === 6) {
        //   td.style.textAlign = "right";
        } else {
          if (!Number.isInteger(stats.deaths) && stats.deaths.includes("+1")) {td.style.color = "red"}
          else if (!Number.isInteger(value) && value.includes("+")) td.style.color = "green"
          td.style.textAlign = "right";
        }
        td.style.padding = "5px";
        row.appendChild(td);
      });
      table.appendChild(row);
    });

    teamDiv.appendChild(table);
    return teamDiv;
  }

  // The original function to render full match details (aggregated over rounds).
  function renderMatchDetails(matchID, gf) {
    const match = gf == 0 ? matches[matchID] : groupfights[matchID];
    const contentDiv = document.getElementById("content");
    contentDiv.classList.remove("landing");
    contentDiv.classList.add("match-detail");
    contentDiv.innerHTML = ""; // Clear previous content
    
    const body = document.body;
    body.style.backgroundRepeat = "no-repeat"; 
    body.style.backgroundPosition = "center center"; 
    body.style.backgroundAttachment = "fixed"; 
    body.style.backgroundSize = "cover"; 
    
    const bgSrc = match.map.toLowerCase().replaceAll(" ", "_").replaceAll("'","");
    if (bgSrc == -1){
      body.style.backgroundImage = `url('assets/img/mb2.png')`;

    } else {
      body.style.backgroundImage = `url('assets/img/bg_${bgSrc}.png')`;

    }

    renderTabBar(contentDiv, "matches");
    const tabContentContainer = document.createElement("div");
    tabContentContainer.id = "tab-content";
    tabContentContainer.style.marginTop = "20px";

    // Match info header
    const mapHeading = document.createElement("h1");
    mapHeading.textContent = `${match.map}`;
    tabContentContainer.appendChild(mapHeading);

    // Compute overall score from round results:
    let team0Score = 0;
    let team1Score = 0;
    match.rounds.forEach(round => {
        if (round.result.includes("Team 2 win")) {
          if (round.result.includes("flag"))
            {team1Score++} else {team0Score++};
        } else if (round.result.includes("Team 1 win")) {
          if (round.result.includes("flag"))
            {team0Score++} else {team1Score++};
        }
    });
    const scoreElement = document.createElement("h1");
    scoreElement.textContent = `${team0Score} - ${team1Score}`;
    scoreElement.style.textAlign = "center";
    scoreElement.style.cursor = "pointer";

    const halfHeaderContainer = document.createElement("div");
    halfHeaderContainer.style.display = "flex";
    halfHeaderContainer.style.flexDirection = "column";
    halfHeaderContainer.style.alignItems = "center";

    // Row for Half 1:
    const half1Row = document.createElement("div");
    half1Row.style.display = "flex";
    half1Row.style.width = "100%";
    half1Row.style.justifyContent = "space-between";
    half1Row.style.alignItems = "center";

    const half1Faction1Div = document.createElement("h2");
    for(let i = 0; i < team0Score; i++){
      const fac11Img = document.createElement("img");
      const flag11 = facIcons[factions.indexOf(match.faction_1)];
      fac11Img.src = `assets/img/${flag11}.png`;
      fac11Img.style.padding = "10px";
      half1Faction1Div.appendChild(fac11Img);
    }
    half1Faction1Div.style.flex = "1";
    half1Faction1Div.style.textAlign = "center";
    //half1Faction1Div.textContent = half1Info.faction_1;

    const half1Faction2Div = document.createElement("h2");
    for(let i = 0; i < team1Score; i++){
      const fac12Img = document.createElement("img");
      const flag12 = facIcons[factions.indexOf(match.faction_2)];
      fac12Img.style.padding = "10px";
      fac12Img.src = `assets/img/${flag12}.png`;
      half1Faction2Div.appendChild(fac12Img);
    }
    half1Faction2Div.style.flex = "1";
    half1Faction2Div.style.textAlign = "center";
    //half1Faction2Div.textContent = half1Info.faction_2;

    // const half1Team1ScoreDiv = document.createElement("h1");
    // half1Team1ScoreDiv.style.flex = "1";
    // half1Team1ScoreDiv.style.textAlign = "left";
    // half1Team1ScoreDiv.textContent = m1team1Score;

    // Make the entire row clickable:
    half1Row.style.cursor = "pointer";
    half1Row.onclick = () => {
      if (gf) updateURLToGFMatch(matchID, 0);
      else updateURLToMatch(matchID, 0);
    };

    half1Row.appendChild(half1Faction1Div);
    half1Row.appendChild(scoreElement);
    half1Row.appendChild(half1Faction2Div);

    // factionsHeader.appendChild(factionsLeft);
    // factionsHeader.appendChild(scoreElement);
    tabContentContainer.appendChild(half1Row);
    contentDiv.appendChild(tabContentContainer);

    // Instead of listing rounds, render aggregated statistics for the match.
    calculateTotalStats(match);
  }

  
  let activeTimeouts = [];
  function cancelAllMessages() {
    activeTimeouts.forEach(clearTimeout); // Clear all scheduled timeouts
    activeTimeouts = []; // Reset the array
  }

  // New function: renderSingleRound displays match info and stats for one round only.
  function renderSingleRound(matchID, roundIndex, gf) {
    const match = gf == 0 ? matches[matchID] : groupfights[matchID];
    const round = match.rounds[roundIndex];
    const contentDiv = document.getElementById("content");
    contentDiv.classList.remove("bracket");
    contentDiv.classList.remove("landing");
    contentDiv.classList.add("match-detail");
    contentDiv.innerHTML = "";  // Clear existing content
    cancelAllMessages()

    // Create a container for the messages in the bottom-left corner
    const messageContainer = document.createElement("div");
    messageContainer.style.position = "fixed";
    messageContainer.style.bottom = "10px";
    messageContainer.style.left = "10px";
    messageContainer.style.zIndex = "1000"; // Ensure it's over other content
    messageContainer.style.display = "flex";
    messageContainer.style.flexDirection = "column";
    messageContainer.style.gap = "5px"; // Add spacing between messages
    document.body.appendChild(messageContainer);


    // Function to convert a timestamp to seconds
    function timestampToSeconds(timestamp) {
      const timeParts = timestamp.split(":").map(Number); // Split and parse the timestamp
      return timeParts[0] * 3600 + timeParts[1] * 60 + timeParts[2]; // Convert to seconds
    }

    // Determine the earlier time between flag_time and first death time
    const flagInSeconds = round.flag_time.length > 0 ? timestampToSeconds(round.flag_time[0]) : 999999999;
    const firstDeathInSeconds = timestampToSeconds(round.death_times[0]);
    const earliestTimeInSeconds = Math.min(flagInSeconds, firstDeathInSeconds); // Use the earlier time

    // Function to calculate the delay from the earliest time
    function calculateDelay(timestamp) {
      const timestampInSeconds = timestampToSeconds(timestamp); // Convert to seconds
      return (timestampInSeconds - earliestTimeInSeconds) * 333; // Delay in milliseconds / 5
    }

    // Show a message on screen
    function showMessage(content, delay, textcol) {
      const timeoutId = setTimeout(() => {
        const message = document.createElement("div");
        message.style.padding = "5px 10px"; 
        message.style.fontSize = "20px"; 
        message.style.color = textcol;
        message.style.boxSizing = "border-box"; 
        message.style.margin = "0"; 

        message.style.display = "flex"; // Use flex to align text, icon, and victim name
        message.style.alignItems = "center"; // Center align items vertically
        //message.style.gap = "10px"; // Add space between elements
        message.style.transition = "opacity 2s ease-out"; // Fade-out transition
        message.style.opacity = "1"; // Initially fully visible

        groups = content.split(" ");
        if(groups[1]?.includes("ico")){
          // Add killer text
          const killer = document.createElement("span");
          killer.textContent = groups[0] + "  ";

          // if (groups[0]) {
          //   const cell = document.querySelector(`td[data-player="${groups[0]}"]`);
          //   if (cell) {
          //     cell.style.color = "#34D313"; // Turn text red for a death
          //   }
          // }

          // Add the icon
          const icon = document.createElement("img");
          icon.src = `assets/img/${groups[1]}.png`; // Set the source of the icon
          icon.alt = "Icon"; // Provide alt text for accessibility
          icon.style.objectFit = "contain"; // Ensure the icon scales well
          icon.style.margin = "0 5px";

          // Add victim text
          const victim = document.createElement("span");
          victim.textContent = "  " + groups[2];

          if (groups[2]) {
            // Locate the corresponding table cell using `data-player`
            const cell = document.querySelector(`td[data-player="${groups[2]}"]`);
            if (cell) {
              cell.style.color = "red"; // Turn text red for a death
              cell.children[0].style.filter = `grayscale(1)`;
            }
          }
          
          // Append killer, icon, and victim to the message
          message.appendChild(killer);
          message.appendChild(icon);
          message.appendChild(victim);

        } else {
          message.textContent = content;
        }
        messageContainer.appendChild(message);

    // Start fade-out after 5 seconds
    const fadeTimeoutId = setTimeout(() => {
      message.style.opacity = "0"; // Reduce opacity to make it fade out

        setTimeout(() => {
          messageContainer.removeChild(message);
        }, 5000);
      }, 5000);
    }, delay);
    activeTimeouts.push(timeoutId);
  }


    let tkid = 0;

    // Loop through death times and schedule messages
    round.death_times.forEach((x, id) => {
      const delay = calculateDelay(x, round.start_time); // Calculate delay based on start time
      
      // Determine the message content
      let messageContent, textColor;
      let tkmessageContent;
      if (round.deaths[id] == round.teamkilled[tkid]) {
        const killerIndex = round.players.indexOf(round.teamkills[tkid]);
        if (killerIndex !== -1) {
          const killerTeam = round.teams[killerIndex]; // Get the killer's team (0 or 1)
          textColor = killerTeam === 0 ? "#59261B" : "#34D313"; //59261B
        }
        tkmessageContent = `${round.teamkills[tkid]} has killed a teammate!`;
        messageContent = `${round.teamkills[tkid]} ${round.tkicons[tkid]} ${round.deaths[id]}`;
        tkid++;
      } else {
        const killerIndex = round.players.indexOf(round.kills[id - tkid]);
        if (killerIndex !== -1) {
          const killerTeam = round.teams[killerIndex]; // Get the killer's team (0 or 1)
          textColor = killerTeam === 0 ? "#34D313" : "#F34323"; //59261B
        }
        messageContent = `${round.kills[id - tkid]} ${round.icons[id - tkid]} ${round.deaths[id]}`;
      }

    // Show the message
    if (tkmessageContent) showMessage(tkmessageContent, delay, textColor);
    showMessage(messageContent, delay, textColor);
    });

    // Schedule message for flag time
    if(round.flag_time.length > 0){
      const flagDelay = calculateDelay(round.flag_time[0], round.start_time);
      showMessage("Flag spawned!", flagDelay);
    }

    // Schedule message for round end time
    const endDelay = calculateDelay(round.end_time, round.start_time);
    const winFac = getWinner(round.result) == 0 ? match.faction_1 : match.faction_2;
    if (round.result == "Round draw."){
      showMessage(`Round draw!`, endDelay);
    } else {
      const resultFlag = round.result.includes("higher") ? "by flag control!" : "by raising the flag!";
      const result = round.result.includes("flag") ? `${winFac} won the round ${resultFlag}` : `${winFac} won the round!`;
      showMessage(`${result}`, endDelay);
    }

    renderTabBar(contentDiv, "matches");
    const tabContentContainer = document.createElement("div");
    tabContentContainer.id = "tab-content";
    tabContentContainer.style.marginTop = "20px";

    // Header with basic match info; you might want to include the round's start time.
    const mapHeading = document.createElement("h1");
    mapHeading.textContent = `${match.map} (Round ${roundIndex + 1})`;
    tabContentContainer.appendChild(mapHeading);

    // For a single round, you might decide to show no score or compute a score based on round.result.
    const scoreElement = document.createElement("h1");

    let team0Score, team1Score;
    let cumulativeTeam0 = 0, cumulativeTeam1 = 0;
    let currentChangeTeam0 = 0, currentChangeTeam1 = 0;

if (roundIndex === 0) {
    // For round 0, there are no previous rounds. Use the current round only.
    const round = match.rounds[0];
    if (round.result.includes("Draw")) {
        team0Score = "0";
        team1Score = "0";
    } else if (round.result.includes("Team 2 win")) {
        if (round.result.includes("flag")) {
            team1Score = "+1";
            currentChangeTeam1 = 1;
            team0Score = "0";
        } else {
            team0Score = "+1";
            currentChangeTeam0 = 1;
            team1Score = "0";
        }
    } else if (round.result.includes("Team 1 win")) {
        if (round.result.includes("flag")) {
            team0Score = "+1";
            currentChangeTeam0 = 1;
            team1Score = "0";
        } else {
            team1Score = "+1";
            currentChangeTeam1 = 1;
            team0Score = "0";
        }
    } else {
        team0Score = "0";
        team1Score = "0";
    }
} else {
    // Compute aggregate score from rounds 0 to roundIndex-1
    for (var i = 0; i < roundIndex; i++) {
        let r = match.rounds[i];
        if (r.result.includes("Team 2 win")) {
            if (r.result.includes("flag")) {
                cumulativeTeam1++;
            } else {
                cumulativeTeam0++;
            }
        } else if (r.result.includes("Team 1 win")) {
            if (r.result.includes("flag")) {
                cumulativeTeam0++;
            } else {
                cumulativeTeam1++;
            }
        }
    }

    // Determine current round change from roundIndex only.
    const currentRound = match.rounds[roundIndex];
    if (currentRound.result.includes("Draw")) {
        // For draw, we show "Draw - cumulativeTeam0 - cumulativeTeam1"
        team0Score = "Draw - " + cumulativeTeam0;
        team1Score = "Draw - " + cumulativeTeam1;
    } else if (currentRound.result.includes("Team 2 win")) {
        if (currentRound.result.includes("flag")) {
            currentChangeTeam1 = 1;
        } else {
            currentChangeTeam0 = 1;
        }
        team0Score = currentChangeTeam0 > 0 ? "+" + currentChangeTeam0 : cumulativeTeam0.toString();
        team1Score = currentChangeTeam1 > 0 ? "+" + currentChangeTeam1 : cumulativeTeam1.toString();
    } else if (currentRound.result.includes("Team 1 win")) {
        if (currentRound.result.includes("flag")) {
            currentChangeTeam0 = 1;
        } else {
            currentChangeTeam1 = 1;
        }
        team0Score = currentChangeTeam0 > 0 ? " +" + currentChangeTeam0 : cumulativeTeam0.toString();
        team1Score = currentChangeTeam1 > 0 ? " +" + currentChangeTeam1 : cumulativeTeam1.toString();
    } else {
        team0Score = cumulativeTeam0.toString();
        team1Score = cumulativeTeam1.toString();
    }
}
    scoreElement.textContent = `${team0Score} - ${team1Score}`;
    scoreElement.style.textAlign = "center";
    scoreElement.style.cursor = "pointer";

    const halfHeaderContainer = document.createElement("div");
    halfHeaderContainer.style.display = "flex";
    halfHeaderContainer.style.flexDirection = "column";
    halfHeaderContainer.style.alignItems = "center";

    // Row for Half 1:
    const half1Row = document.createElement("div");
    half1Row.style.display = "flex";
    half1Row.style.width = "100%";
    half1Row.style.justifyContent = "space-between";
    half1Row.style.alignItems = "center";

    half1Row.style.cursor = "pointer";
    half1Row.onclick = () => {
      if (roundIndex + 1 < match.rounds.length) {
        if (gf) updateURLToGFMatch(matchID, roundIndex + 1);
        else updateURLToMatch(matchID, roundIndex + 1);// Render the next round
      } else {
        if (gf) updateURLToGFMatch(matchID);
        else updateURLToMatch(matchID); // Return to match details if it's the last round
      }
    }
    const half1Faction1Div = document.createElement("h2");
    for(let i = 0; i < cumulativeTeam0 + currentChangeTeam0; i++){
      const fac11Img = document.createElement("img");
      const flag11 = facIcons[factions.indexOf(match.faction_1)];
      fac11Img.src = `assets/img/${flag11}.png`;
      fac11Img.style.padding = "10px";
      half1Faction1Div.appendChild(fac11Img);
    }
    half1Faction1Div.style.flex = "1";
    half1Faction1Div.style.textAlign = "center";
    //half1Faction1Div.textContent = half1Info.faction_1;

    const half1Faction2Div = document.createElement("h2");
    for(let i = 0; i <  cumulativeTeam1 + currentChangeTeam1; i++){
      const fac12Img = document.createElement("img");
      const flag12 = facIcons[factions.indexOf(match.faction_2)];
      fac12Img.style.padding = "10px";
      fac12Img.src = `assets/img/${flag12}.png`;
      half1Faction2Div.appendChild(fac12Img);
    }
    half1Faction2Div.style.flex = "1";
    half1Faction2Div.style.textAlign = "center";
    half1Row.appendChild(half1Faction1Div);
    half1Row.appendChild(scoreElement);
    half1Row.appendChild(half1Faction2Div);

    // factionsHeader.appendChild(factionsLeft);
    // factionsHeader.appendChild(scoreElement);
    tabContentContainer.appendChild(half1Row);

  // Handle stats differently for Round 0
  if (roundIndex === 0) {
    // Stats for the current round only
    const currentStats = getPlayerStats([match.rounds[roundIndex]]);
    //console.log(currentStats)
    // Split and sort players by teams
    const { team0, team1 } = splitAndSortByTeam(currentStats);

    // Format stats to only show current values as "+value" or "0"
    const formattedTeam0 = team0.map(([player, stats]) => {
      const formattedStats = {};
      Object.keys(stats).forEach(key => {
        if (key !== "team" && key !== "classes") {
          const value = stats[key] || 0;
          formattedStats[key] = value > 0 ? `+${value}` : "0";
        }
      });
      return [player, { ...stats, ...formattedStats }];
    });

    const formattedTeam1 = team1.map(([player, stats]) => {
      const formattedStats = {};
      Object.keys(stats).forEach(key => {
        if (key !== "team" && key !== "classes") {
          const value = stats[key] || 0;
          formattedStats[key] = value > 0 ? `+${value}` : "0";
        }
      });
      return [player, { ...stats, ...formattedStats }];
    });


    const statsContainer = document.createElement("div");
    statsContainer.className = "stats-container";  // Use your pre-defined CSS

    // Display formatted stats for Round 0
    const tableWrapper = document.createElement("div");
    tableWrapper.id = "tables-container";
    tableWrapper.className = "table-wrapper";
    tableWrapper.style.display = "flex";
    //tableWrapper.style.gap = "30px";

    tableWrapper.appendChild(generateTeamTableCommon(formattedTeam0, match.faction_1, 1));
    tableWrapper.appendChild(generateTeamTableCommon(formattedTeam1, match.faction_2, 1));

    statsContainer.appendChild(tableWrapper)

    
    // scroll down for better killfeed legibility
    const extraSpace = document.createElement("div");
    extraSpace.style.height = "150px"; 
    statsContainer.appendChild(extraSpace);


    tabContentContainer.appendChild(statsContainer);
    contentDiv.appendChild(tabContentContainer);
    adjustTableLayout();
  } else {
    // Handle rounds beyond Round 0
    const aggregateRounds = match.rounds.slice(0, roundIndex + 1);
    const aggregatePlayerStats = getPlayerStats(aggregateRounds);
    const currentRoundStats = getPlayerStats([match.rounds[roundIndex]]);

    const { team0, team1 } = computeRoundChanges(aggregatePlayerStats, currentRoundStats);

    const tableWrapper = document.createElement("div");
    tableWrapper.id = "tables-container";
    tableWrapper.className = "table-wrapper";
    tableWrapper.style.display = "flex";
    //tableWrapper.style.gap = "30px";

    const statsContainer = document.createElement("div");
    statsContainer.className = "stats-container";  // Use your pre-defined CSS

    tableWrapper.appendChild(generateTeamTableCommon(team0, match.faction_1, 1));
    tableWrapper.appendChild(generateTeamTableCommon(team1, match.faction_2, 1));

    statsContainer.appendChild(tableWrapper);

    // scroll down for better killfeed legibility
    const extraSpace = document.createElement("div");
    extraSpace.style.height = "150px"; 
    statsContainer.appendChild(extraSpace);

    tabContentContainer.appendChild(statsContainer);
    contentDiv.appendChild(tabContentContainer);
    adjustTableLayout();
  }
  }

  function computeRoundChanges(aggregatePlayerStats, currentPlayerStats) {
  const team0 = [];
  const team1 = [];
    //console.log(aggregatePlayerStats, currentPlayerStats)
  // Step 1: Sort players by team using splitAndSortByTeam
  const { team0: sortedTeam0, team1: sortedTeam1 } = splitAndSortByTeam(aggregatePlayerStats);

  // Step 2: Process Team 0 players
  sortedTeam0.forEach(([player, aggregateStats]) => {
    const currStats = currentPlayerStats[player] || {}; // Current stats for the player (default empty if not present)
    const prevStats = {}; // Initialize previous stats to calculate

    // Compute stats before current round by subtracting current stats from aggregate
    Object.keys(aggregateStats).forEach(key => {
      if (key !== "team") {
        const aggregateValue = aggregateStats[key] || 0;
        const currentValue = currStats[key] || 0;
        prevStats[key] = aggregateValue - currentValue;
      } 
    });

    // Generate display values by combining prevStats and currStats
    const statsWithChanges = {};
    Object.keys(prevStats).forEach(key => {
      const prevValue = prevStats[key] || 0;
      const currValue = currStats[key] || 0;
      const change = currValue; // Change is the current round's value
      statsWithChanges[key] = change > 0 ? `+${change}` : `${prevValue}`;
      if(key == "classes") statsWithChanges[key] = currValue;
    });
    // Push updated stats with changes into the team array
    team0.push([player, { ...aggregateStats, ...statsWithChanges }]);
  });

  // Step 3: Process Team 1 players
  sortedTeam1.forEach(([player, aggregateStats]) => {
    const currStats = currentPlayerStats[player] || {};
    const prevStats = {};

    // Compute stats before current round by subtracting current stats from aggregate
    Object.keys(aggregateStats).forEach(key => {
      if (key !== "team") {
        const aggregateValue = aggregateStats[key] || 0;
        const currentValue = currStats[key] || 0;
        prevStats[key] = aggregateValue - currentValue;
      }
    });

    // Generate display values by combining prevStats and currStats
    const statsWithChanges = {};
    Object.keys(prevStats).forEach(key => {
      const prevValue = prevStats[key] || 0;
      const currValue = currStats[key] || 0;
      const change = currValue; // Change is the current round's value
      statsWithChanges[key] = change > 0 ? `+${change}` : `${prevValue}`;
      if(key == "classes") statsWithChanges[key] = currValue;
    });

    // Push updated stats with changes into the team array
    team1.push([player, { ...aggregateStats, ...statsWithChanges }]);
  });
  //console.log("TEAMS", team0, team1)
  return { team0, team1 };
}

  function getHalfAggregate(halfIndices) {
  let combinedRounds = [];
  let team0Score = 0;
  let team1Score = 0;
  let faction1 = "";
  let faction2 = "";
  
  halfIndices.forEach((mIndex, i) => {
    const matchObj = matches[mIndex];
    if (matchObj && matchObj.rounds) {
      // For the first match in the half, store the faction names.
      if (i === 0) {
        faction1 = matchObj.faction_1;
        faction2 = matchObj.faction_2;
      }
      // For each match, we assume your renderHalf logic was to flip the rounds in the
      // second match. Here, we use that same idea:
      matchObj.rounds.forEach(round => {
        // For the second match in a half, we flip the round.
        const processedRound = (i === 1) ? flipRound(round) : round;
        combinedRounds.push(processedRound);
        // Score logic: for match index 0 (first match), if round.result includes "Team 2 win" then team0Score++,
        // and if it includes "Team 1 win" then team1Score++.
        // For match index 1, since we flipped rounds, we use the normal logic.
          if (i === 0) {
            if (round.result.includes("Team 2 win")) {
              if (round.result.includes("flag"))
                {team1Score++} else {team0Score++};
            } else if (round.result.includes("Team 1 win")) {
              if (round.result.includes("flag"))
                {team0Score++} else {team1Score++};
            }
          } else {
            if (round.result.includes("Team 2 win")) {
              if (round.result.includes("flag"))
                {team0Score++} else {team1Score++};
            } else if (round.result.includes("Team 1 win")) {
              if (round.result.includes("flag"))
                {team1Score++} else {team0Score++};
            }
          }
      });
    }
  });
  
  // Now, aggregate player stats from all combined rounds.
  const aggregatedStats = getPlayerStats(combinedRounds);
  return { aggregatedStats, team0Score, team1Score, faction1, faction2 };
}

/**
 * Flips a round's team assignments: every team assignment of 0 becomes 1, and 1 becomes 0.
 * (Other round data is shallow-copied.)
 */
function flipRound(round) {
  return {
    players: round.players.slice(),
    teams: round.teams.map(t => t === 0 ? 1 : 0),
    kills: round.kills.slice(),
    deaths: round.deaths.slice(),
    assists: round.assists.slice(),
    dmg: round.dmg.slice(),
    teamkills: round.teamkills.slice(),
    tdmg: round.tdmg.slice(),
    result: round.result
  };
}

/**
 * Given an aggregate object produced by getHalfAggregate(),
 * returns a new aggregate where team assignments and scores are swapped.
 */
function swapHalfAggregate(agg) {
  const swappedStats = {};
  Object.entries(agg.aggregatedStats).forEach(([player, stats]) => {
    // Swap stats.team.
    let newTeam = stats.team === 0 ? 1 : 0;
    swappedStats[player] = Object.assign({}, stats, { team: newTeam });
  });
  return {
    aggregatedStats: swappedStats,
    team0Score: agg.team1Score,
    team1Score: agg.team0Score,
    faction1: agg.faction1, // optionally, you might swap these too if needed, but here we keep them.
    faction2: agg.faction2
  };
}

/**
 * Merges two aggregated stats objects. For any player appearing in both,
 * the stats are summed. Otherwise, the entry is simply added.
 */
function mergeAggregates(agg1, agg2) {
  const merged = Object.assign({}, agg1);
  Object.entries(agg2).forEach(([player, stats]) => {
    if (merged[player]) {
      // Sum the stats.
      merged[player].kills += stats.kills;
      merged[player].deaths += stats.deaths;
      merged[player].assists += stats.assists;
      merged[player].dmg += stats.dmg;
      merged[player].teamkills += stats.teamkills;
      merged[player].tdmg += stats.tdmg;
      merged[player].classes += stats.classes;
    } else {
      merged[player] = stats;
    }
  });
  return merged;
}

/**
 * Renders a scrim display. scrimSpec should be an array [halfId1, halfId2, s].
 * It aggregates two halves and then, if s === 0, flips the second halfâ€™s results.
 */
function renderScrim(scrimSpec) {
  const [halfId1, halfId2, s] = scrimSpec;

  // if (!window.history.state || window.history.state.tab !== tab) {
  //   const baseUrl = window.location.origin + window.location.pathname;
  //   window.history.pushState({ scrim: scrimId }, "", `${baseUrl}?scrim=${scrimId}`);
  // }
  // Obtain aggregated statistics for each half.
  let halfAgg1 = getHalfAggregate(halfs[halfId1]);
  let halfAgg2 = getHalfAggregate(halfs[halfId2]);
  
  // If s is 0, then we want to flip the second half's teams before merging.
  if (s === 0) {
    halfAgg2 = swapHalfAggregate(halfAgg2);
  }
  
  // Compute final scores.
  const finalTeam0Score = halfAgg1.team0Score + halfAgg2.team0Score;
  const finalTeam1Score = halfAgg1.team1Score + halfAgg2.team1Score;
  
  // Merge the aggregated stats.
  const finalAggregatedStats = mergeAggregates(halfAgg1.aggregatedStats, halfAgg2.aggregatedStats);
  const { team0, team1 } = splitAndSortByTeam(finalAggregatedStats);
  
  // Render the scrim view.
  const contentDiv = document.getElementById("content");
  contentDiv.classList.remove("landing");
  contentDiv.classList.add("match-detail");
  contentDiv.innerHTML = ""; // Clear previous content
  
  // "Back" button.
  // const backButton = document.createElement("button");
  // backButton.textContent = "Back to Matches";
  // backButton.style.marginBottom = "20px";
  // backButton.onclick = updateURLToLanding;
  // contentDiv.appendChild(backButton);
  renderTabBar(contentDiv, "tournaments");
  const tabContentContainer = document.createElement("div");
  tabContentContainer.id = "tab-content";
  tabContentContainer.style.marginTop = "20px";

  // Get header info for each half from the first match of each half.
  const half1Info = matches[halfs[halfId1][0]];
  const half2Info = matches[halfs[halfId2][0]];
// Create a container for the half header details (stacked rows, centered)
const halfHeaderContainer = document.createElement("div");
halfHeaderContainer.style.display = "flex";
halfHeaderContainer.style.flexDirection = "column";
halfHeaderContainer.style.alignItems = "center";

// Row for Half 1:
const half1Row = document.createElement("div");
half1Row.style.display = "flex";
half1Row.style.width = "100%";
half1Row.style.justifyContent = "space-between";
half1Row.style.alignItems = "center";
// Create five flex cells (each 20% width)
const half1Team0ScoreDiv = document.createElement("h1");
half1Team0ScoreDiv.style.flex = "1";
half1Team0ScoreDiv.style.textAlign = "right";
half1Team0ScoreDiv.textContent = halfAgg1.team0Score;

const half1Faction1Div = document.createElement("h2");
const fac11Img = document.createElement("img");
const flag11 = facIcons[factions.indexOf(half1Info.faction_1)];
fac11Img.src = `assets/img/${flag11}.png`;
half1Faction1Div.appendChild(fac11Img);
half1Faction1Div.style.flex = "1";
half1Faction1Div.style.textAlign = "center";
//half1Faction1Div.textContent = half1Info.faction_1;

const half1MapDiv = document.createElement("h1");
half1MapDiv.style.flex = "1";
half1MapDiv.style.textAlign = "center";
half1MapDiv.textContent = half1Info.map;

const half1Faction2Div = document.createElement("h2");
const fac12Img = document.createElement("img");
const flag12 = facIcons[factions.indexOf(half1Info.faction_2)];
fac12Img.src = `assets/img/${flag12}.png`;
half1Faction2Div.appendChild(fac12Img);
half1Faction2Div.style.flex = "1";
half1Faction2Div.style.textAlign = "center";
//half1Faction2Div.textContent = half1Info.faction_2;

const half1Team1ScoreDiv = document.createElement("h1");
half1Team1ScoreDiv.style.flex = "1";
half1Team1ScoreDiv.style.textAlign = "left";
half1Team1ScoreDiv.textContent = halfAgg1.team1Score;

// Make the entire row clickable:
half1Row.style.cursor = "pointer";
half1Row.onclick = () => {
  updateURLToHalf(halfId1);
};

half1Row.appendChild(half1Team0ScoreDiv);
half1Row.appendChild(half1Faction1Div);
half1Row.appendChild(half1MapDiv);
half1Row.appendChild(half1Faction2Div);
half1Row.appendChild(half1Team1ScoreDiv);

// Row for Half 2:
const half2Row = document.createElement("div");
half2Row.style.display = "flex";
half2Row.style.width = "100%";
half2Row.style.justifyContent = "space-between";
half2Row.style.alignItems = "center";

const half2Team0ScoreDiv = document.createElement("h1");
half2Team0ScoreDiv.style.flex = "1";
half2Team0ScoreDiv.style.textAlign = "right";
half2Team0ScoreDiv.textContent = halfAgg2.team0Score;

const half2Faction1Div = document.createElement("h2");
const fac21Img = document.createElement("img");
const flag21 = facIcons[factions.indexOf(half2Info.faction_1)];
fac21Img.src = `assets/img/${flag21}.png`;
half2Faction1Div.appendChild(fac21Img);
half2Faction1Div.style.flex = "1";
half2Faction1Div.style.textAlign = "center";
// half2Faction1Div.textContent = 

const half2MapDiv = document.createElement("h1");
half2MapDiv.style.flex = "1";
half2MapDiv.style.textAlign = "center";
half2MapDiv.textContent = half2Info.map;

const half2Faction2Div = document.createElement("h2");
const fac22Img = document.createElement("img");
const flag22 = facIcons[factions.indexOf(half2Info.faction_2)];
fac22Img.src = `assets/img/${flag22}.png`;
half2Faction2Div.appendChild(fac22Img);
half2Faction2Div.style.flex = "1";
half2Faction2Div.style.textAlign = "center";

// half2Faction2Div.textContent = half2Info.faction_2;

const half2Team1ScoreDiv = document.createElement("h1");
half2Team1ScoreDiv.style.flex = "1";
half2Team1ScoreDiv.style.textAlign = "left";
half2Team1ScoreDiv.textContent = halfAgg2.team1Score;

half2Row.style.cursor = "pointer";
half2Row.onclick = () => {
  updateURLToHalf(halfId2);
};

half2Row.appendChild(half2Team0ScoreDiv);
half2Row.appendChild(half2Faction1Div);
half2Row.appendChild(half2MapDiv);
half2Row.appendChild(half2Faction2Div);
half2Row.appendChild(half2Team1ScoreDiv);

// Append both rows to the container:
halfHeaderContainer.appendChild(half1Row);
halfHeaderContainer.appendChild(half2Row);

// Overall total score (centered below)
const totalScoreDiv = document.createElement("h1");
totalScoreDiv.style.fontSize = "2.5em"; 
totalScoreDiv.style.textAlign = "center";
totalScoreDiv.textContent = `${finalTeam0Score} - ${finalTeam1Score}`;

// Append the header container and total score to the contentDiv
tabContentContainer.appendChild(halfHeaderContainer);
tabContentContainer.appendChild(totalScoreDiv);
  // Create side-by-side tables.
  const tableWrapper = document.createElement("div");
  tableWrapper.className = "table-wrapper";
  tableWrapper.id = "tables-container";
  tableWrapper.style.display = "flex";
  //tableWrapper.style.gap = "30px";
  
  // For scrims, we assume faction names are taken from the first halfâ€™s first match.
  const faction0 = matches[halfs[halfId1][0]].faction_1;
  const faction1 = matches[halfs[halfId1][0]].faction_2;
  
  const statsContainer = document.createElement("div");
    statsContainer.className = "stats-container";  // Use your pre-defined CSS

  tableWrapper.appendChild(generateTeamTableCommon(team0, faction0));
  tableWrapper.appendChild(generateTeamTableCommon(team1, faction1));
  
  statsContainer.appendChild(tableWrapper);
  tabContentContainer.appendChild(statsContainer);
  contentDiv.appendChild(tabContentContainer);
  adjustTableLayout();
}
const RobAIbracket = [
      // ["Cheezeninja", "Marquis", "X", "X", -1],
      ["Ebdanian", "Hemp", 9, 6, 0],
      // ["Marquis", "Ebdanian", "X", "X", -1],
      ["Roberta", "Cheezeninja", 9, 6, 1],
      ["Ebdanian", "Roberta", 4, 12, 2],
      ["Hemp", "Marquis", 12, 6, 3],
      ["Roberta", "Hemp", 2, 12, 5],
      ["Cheezeninja", "Ebdanian", 9, 8, 6],
      ["Hemp", "Cheezeninja", 9, 1, 7],
      ["Marquis", "Roberta", 4, 9, 4],
      ["Ebdanian", "Hemp", 9, 3, 8],
      ["Roberta", "Cheezeninja", 8, 8, 10],
      ["Roberta", "Cheezeninja", 0, 3, 11],
      ["Ebdanian", "Cheezeninja", 9, 7, 9],
    ];

    const Mayhembracket = [
      // ["team1", "team2", 1, 0, 0],//score1, score2, scrim #
      ["Chowski/Roberta", "Crusader/Vampy", "x", "x", -1],
      ["Potesty/Exmarius", "Les/MattTheLord", 15, 3, 0],
      ["Beansacks/John", "Pichu/Thiago", 15, 7, 8],
      ["Nasa/CheeseNinja", "BrownMilk/Kurm", 1, 15, 9],
      ["Zealots/Van", "Konrad/Loki", 15, 1, 4],
      ["Sitvek/Kman", "Argo/Ingemar", "x", "0", -1],
      ["BestNAGTA/Chunky", "Powder/Lykia", "0", "x", -1],
      ["Trox/Wert", "Ducreux/Philip", 15, 4, 1],
      //round 2 
      ["Mav/Hemp", "Chowski/Roberta", "0", "x", -1],
      ["Hey/Daemon", "Potesty/Exmarius", 5, 15, 3],
      ["Byunos/Chicken", "Beansacks/John", 15, 6, 11],
      ["Danate/Aporta", "BrownMilk/Kurm",11, 15, 10],
      ["Alyss/Gibby", "Zealots/Van", 15, 0, 5],
      ["Kairos/Shovenio", "Argo/Ingemar", "0", "x", -1],
      ["Cow/PPK157", "BestNAGTA/Chunky", 15, 5, 2],
      ["Marquis/Ebdanian", "Trox/Wert", 15, 13, 6],
      //round 3 
      ["Mav/Hemp", "Potesty/Exmarius", "0", "x", -1],
      ["Byunos/Chicken", "BrownMilk/Kurm", "?", "?", -1],
      ["Alyss/Gibby", "Kairos/Shovenio", 15, 3, 12],
      ["Cow/PPK157", "Marquis/Ebdanian", 15, 11, 7],
      //semifinal
      ["Mav/Hemp", "Semifinalist", "?", "?", -1],
      ["Alyss/Gibby", "Cow/PPK157", 15, 10, 13],
      //finals
      ["Finalist", "Alyss/Gibby", "?", "?", -1],
    ];

    const tournaments = [RobAIbracket, Mayhembracket]


const halfs = [
  //rob tournament
  [0,1],[2,3],[4,5],[6,7],[8,9],
  [10,11],[12,13],[14,15],[16,17],
  [18,19],[20,21],[22,23],[24,25],
  [26,27],[28,29],[30,-1],[31,32],
  [33,-1],[34,35],[36,37],[38,39],
  [40,41],[42,-1],[43,43], //23
];
//43 is an empty match with 0-0 score 
function fillHalfsList() {
  for (let i = 44; i < matches.length; i++) {
    let match1 = matches[i]; 

    if (
      i + 1 < matches.length && 
      matches[i + 1].map === match1.map && 
      matches[i + 1].faction_1 === match1.faction_1 && 
      matches[i + 1].faction_2 === match1.faction_2
    ) {
      
      halfs.push([i, i + 1]);

      i++;
    } else {
      halfs.push([i, 43]);
    }
  }
}
//half1, half2, bSwap
const scrims = [
  [0,1,0],[2,3,0],[4,5,1],
  [6,7,0],[8,9,0],[10,11,0],
  [12,13,1],[14,15,0],[16,17,0],
  [18,19,0],[20,21,1],[22,-1,0],
];

//hardcoding in the tournament arrays start - end matches
const robScramble = [0, 44];

//groupfight tourneys are excluded from global stats, so stored separately 


//March - 24th to end only 
const pickupSeason1 = [44, 73, "MARCH"];

//April 2025
const pickupSeason2 = [74, 348, "APRIL"];

//ongoing season -- move to the fetch response to automate
const currentSeason = [349, 370, "MAY"];

//pickup "seasons" (monthly aggregate)
const pickupSeasons = [pickupSeason1, pickupSeason2, currentSeason];

// Define the tabs. By default "scrims" is active.
const tabs = [
  // { label: "DISCORD", id: "home" },
  { label: "TOURNAMENTS", id: "tournaments" },
  { label: "PICKUPS", id: "matches" },
  { label: "PLAYERS", id: "players" },
  // { label: "MAPS", id: "maps" },
  // { label: "FACTIONS", id: "factions" },
  //{ label: "MAPS", id: "halfs" },
];
let scrollPositions = {};
function renderTabBar(contentDiv, activeTabId){
  
      // Create the tab bar.
      const tabBar = document.createElement("div");
      tabBar.className = "tabs";
      tabs.forEach((tabInfo) => {
            const tab = document.createElement("div");
            tab.className = "tab";
            tab.textContent = tabInfo.label;
            tab.dataset.tab = tabInfo.id;
            // if (tabInfo.id === "bracket") {
            //   tab.classList.add("active");
            // }
            if (tabInfo.id === activeTabId) {
              tab.classList.add("active");
            }
            tab.addEventListener("click", () => {
              const tabContentContainer = document.getElementById("tab-content");
              if (tabContentContainer) {
                //console.log(activeTabId, tabContentContainer.scrollTop)
                scrollPositions[activeTabId] = tabContentContainer.scrollTop; // Save the scroll position for the current tab
              }
              // Remove active class from all tabs.
              document.querySelectorAll(".tabs .tab").forEach((t) => t.classList.remove("active"));
              tab.classList.add("active");
              
              // Render content for the selected tab.
              renderLandingPage(tabInfo.id)
              //renderTabContent(tabInfo.id);
            });
            tabBar.appendChild(tab);
          });
        contentDiv.appendChild(tabBar)
      }
      
function trackScrollPosition(tabId) {
  const tabContentContainer = document.getElementById("tab-content");
  if (tabContentContainer) {
    tabContentContainer.addEventListener("scroll", () => {
      scrollPositions[tabId] = tabContentContainer.scrollTop; // Save the current scroll position for the tab
    });
  }
}
  // --- The rest of your functions handling URL updates, landing page, etc.
  // (They remain largely the same as your existing code.)
  function renderLandingPage(tab) {
      const contentDiv = document.getElementById("content");
      //contentDiv.classList.add("landing");
      contentDiv.innerHTML = ""; // Clear previous content.
      
      cancelAllMessages();
      const baseUrl = window.location.origin + window.location.pathname;  
      if (!window.history.state || window.history.state.tab !== tab) {
        window.history.pushState({ tab: tab }, "", `${baseUrl}?tab=${tab}`);
      }

      renderTabBar(contentDiv, tab);

      // Create a container for the tab-specific content.
      const tabContentContainer = document.createElement("div");
      tabContentContainer.id = "tab-content";
      tabContentContainer.style.marginTop = "20px";

      contentDiv.appendChild(tabContentContainer);
      // Render default tab content ("scrims").
      renderTabContent(tab);
      // Restore scroll position
      //console.log(tab, scrollPositions[tab])
      tabContentContainer.scrollTop = scrollPositions[tab];

    }

    // Renders content for the given tab ID.
    function renderTabContent(tabId) {
      // const container = document.getElementById("content");
      // if (container !== null) container.innerHTML = "";

      const body = document.body;
      body.style.backgroundRepeat = "no-repeat"; 
      body.style.backgroundPosition = "center center"; 
      body.style.backgroundAttachment = "fixed"; 
      body.style.backgroundSize = "cover"; 
      
      if (tabId === "scrims") {
        renderScrimList();
      } else if (tabId === "home") {
        body.style.backgroundImage = "url('assets/img/mb1.png')";
        renderHomeScreen();
      } else if (tabId === "matches") {
        body.style.backgroundImage = "url('assets/img/mb2.png')";
        //renderMatchList();
        renderHalfList(halfs);
      } else if (tabId === "halfs") {
        renderMatchList();
      } else if (tabId === "tournaments") {
        body.style.backgroundImage = "url('assets/img/mb3.png')";
        renderTournamentList();
      // } else if (tabId === "bracket") {
      //   body.style.backgroundImage = "url('assets/img/mb3.png')";
      //   renderBracketList(RobAIbracket);
      } else if (tabId === "teams") {
        renderTeamList();
      } else if (tabId === "players") {
        body.style.backgroundImage = "url('assets/img/mb4.png')";
        renderPlayersList();
      } else {
        //container.textContent = "Unknown tab.";
      }
      trackScrollPosition(tabId);
      const baseUrl = window.location.origin + window.location.pathname;
      window.history.replaceState({ tab: tabId }, "", `${baseUrl}?tab=${tabId}`);
    }

function renderHomeScreen() {
  const contentDiv = document.getElementById("content");
  contentDiv.innerHTML = "";

  renderTabBar(contentDiv, "home");
  const tabContentContainer = document.createElement("div");
  tabContentContainer.id = "tab-content";
  tabContentContainer.style.marginTop = "20px";

  const welcomeTitle = document.createElement("h1");
  welcomeTitle.textContent = "Rat Party";

  const messageContent = document.createElement("div");
  messageContent.style.marginTop = "20px";
  messageContent.textContent = `Welcome brave warrior,`;

  const messageContent2 = document.createElement("div");
  messageContent2.style.marginTop = "20px";
  messageContent2.textContent = `On this page you will find the stats and match history of the freshly undead Warband NA scene. There are both organised tournaments and casual pickup parties weekly.`;

  const messageContent3 = document.createElement("div");
  messageContent3.style.marginTop = "20px";
  messageContent3.textContent = `You can navigate using the Tabs at the top left, and interact by clicking on tiles, scoreboards, and names. You can also see a replay of the Killfeed when viewing individual Rounds.`;

  const messageContent4 = document.createElement("div");
  messageContent4.style.marginTop = "20px";
  messageContent4.textContent = `This page is not about who is good or bad at the game, it is all in good fun to simply record the matches played and show some information that is not readily available in the game itself.`;

  const messageContent5 = document.createElement("div");
  messageContent5.style.marginTop = "20px";
  messageContent5.textContent = `Anyone is more than welcome to play, all you need to do is join the Discord server:`;

  
  const messageContent6 = document.createElement("div");
  messageContent6.style.marginTop = "20px";
  messageContent6.style.marginBottom = "20px";
  messageContent6.textContent = `Happy warbanding`;

  
  const linkDiv = document.createElement("div");
  linkDiv.style.marginBottom = "20px";
  linkDiv.style.marginTop = "50px";
  const link = document.createElement("a");
  link.href = "https://discord.gg/MyucV5GnUv"; // Set the link destination
  link.target = "_blank"; // Open in a new tab (optional)

  const discordLink = document.createElement("img");
  discordLink.alt = "RatParty Discord"
  discordLink.src = "assets/img/Discord-Logo-Blurple.png"
  discordLink.height = discordLink.naturalHeight * 0.1;
  discordLink.onload = () => {
    discordLink.height = discordLink.naturalHeight * 0.1;
  }

  
  link.appendChild(discordLink);
  linkDiv.appendChild(link);

  tabContentContainer.appendChild(welcomeTitle);
  tabContentContainer.appendChild(messageContent);
  tabContentContainer.appendChild(messageContent2);
  tabContentContainer.appendChild(messageContent3);
  tabContentContainer.appendChild(messageContent4);
  tabContentContainer.appendChild(messageContent5);
  tabContentContainer.appendChild(linkDiv);
  tabContentContainer.appendChild(messageContent6);
  contentDiv.appendChild(tabContentContainer);
}

 // Render the Bracket list.
function renderBracketList(bracket) {
  const contentDiv = document.getElementById("content");
  contentDiv.innerHTML = "";


  const body = document.body;

  renderTabBar(contentDiv, "tournaments");
  const tabContentContainer = document.createElement("div");
  tabContentContainer.id = "tab-content";
  tabContentContainer.style.marginTop = "20px";

  const container = document.createElement("div");
  container.id = "bracket";

  if (!bracket || bracket.length === 0) {
    container.textContent = "No bracket available.";
    return;
  }

  // Set up container for responsive wrapping
  container.style.padding = "50px";
  container.style.display = "flex";
  container.style.flexWrap = "wrap";
  container.style.justifyContent = "center"; // Center the boxes

  // For each bracket entry, create a small box
  bracket.forEach((match, index) => {
    // bracket: [Team1, Team2, Team1Score, Team2Score, ScrimID]
    const [team1, team2, team1Score, team2Score, scrimID] = match;
    const box = document.createElement("div");
    box.className = "bracket-box";

    // Style each bracket box
    box.style.border = "1px solid #aaa";
    box.style.borderRadius = "8px";
    box.style.padding = "10px";
    box.style.margin = "10px";
    box.style.minWidth = "150px"; // Minimum width to prevent boxes from collapsing
    box.style.flex = "1 1 200px"; // Allow boxes to shrink and grow while wrapping
    box.style.boxSizing = "border-box"; // Prevent padding from affecting width
    //box.style.backgroundColor = "#f9f9f9";

    const isPlayed = scrimID >= 0;
    if (isPlayed) {
      box.style.border = "3px solid #aaa"; 
      box.style.color = "#ddd";
      box.style.cursor = "pointer";
    }

    box.addEventListener("click", () => {
      const params = new URLSearchParams(window.location.search);
      const bracketStr = params.get("bracket")
      if (bracketStr == 1 && scrimID >= 0) updateURLToGFMatch(scrimID);
      else if (scrimID >= 0) updateURLToScrim(scrimID); // Update the URL and render the Scrim view
    });

    // Top row: Team1 name and its score
    const topRow = document.createElement("div");
    topRow.className = "bracket-row";
    topRow.style.display = "flex";
    topRow.style.justifyContent = "space-between"; // Align name and score
    const team1Name = document.createElement("span");
    team1Name.className = "team-name";
    team1Name.textContent = team1;
    const team1ScoreElem = document.createElement("span");
    team1ScoreElem.className = "team-score";
    team1ScoreElem.textContent = team1Score;
    topRow.appendChild(team1Name);
    topRow.appendChild(team1ScoreElem);

    // Divider
    const divider = document.createElement("hr");
    divider.className = "bracket-divider";
    divider.style.margin = "10px 0";

    // Bottom row: Team2 name and its score
    const bottomRow = document.createElement("div");
    bottomRow.className = "bracket-row";
    bottomRow.style.display = "flex";
    bottomRow.style.justifyContent = "space-between"; // Align name and score
    const team2Name = document.createElement("span");
    team2Name.className = "team-name";
    team2Name.textContent = team2;
    const team2ScoreElem = document.createElement("span");
    team2ScoreElem.className = "team-score";
    team2ScoreElem.textContent = team2Score;
    bottomRow.appendChild(team2Name);
    bottomRow.appendChild(team2ScoreElem);

    // Append rows and scrim ID into the box
    box.appendChild(topRow);
    box.appendChild(divider);
    box.appendChild(bottomRow);

    // Append the box to the container
    container.appendChild(box);
  });
  tabContentContainer.appendChild(container);
  contentDiv.appendChild(tabContentContainer);
}
function renderTournamentList() {


  const container = document.getElementById("tab-content");
  container.innerHTML = "";
  const body = document.body;

  // Create Current Tournament Section
  const currentTournamentDiv = document.createElement("div");
  currentTournamentDiv.className = "current-tournament";

  const currentTournament = { title: "Mountless Mayhem 2v2", info: "Ongoing" };

  // Create Current Tournament Title (as h1)
  const currentTitle = document.createElement("h1");
  currentTitle.textContent = currentTournament.title;

  // Create Current Tournament Info
  const currentInfo = document.createElement("div");
  currentInfo.className = "tournament-info";
  currentInfo.textContent = currentTournament.info;

  // Add onClick to the current tournament
  currentTournamentDiv.onclick = () => {
    updateURLToBracket(1);
    body.style.backgroundImage = "url('assets/img/mb5.png')";
  };

  currentTournamentDiv.appendChild(currentTitle);
  currentTournamentDiv.appendChild(currentInfo);
  container.appendChild(currentTournamentDiv);

  // Create Previous Tournaments Section
  const previousTournamentsDiv = document.createElement("div");
  previousTournamentsDiv.className = "previous-tournaments";

  // Add COMPLETED Section Title (centered with borders)
  const completedTitle = document.createElement("div");
  completedTitle.className = "completed-title";
  completedTitle.textContent = "COMPLETED TOURNAMENTS:";

  // Create List of Previous Tournaments
  const previousTournaments = ["Roberta's 2025 Scramble League"];
  const previousList = document.createElement("ul");
  previousTournaments.forEach((tournament) => {
    const listItem = document.createElement("li");
    listItem.textContent = tournament;
    listItem.style.margin = "0px";
    listItem.style.padding = "20px";

    // Add onClick to each previous tournament
    listItem.onclick = () => {
      updateURLToBracket(0);
      body.style.backgroundImage = "url('assets/img/mb3.png')";
    };

    previousList.appendChild(listItem);
  });

  previousTournamentsDiv.appendChild(completedTitle);
  previousTournamentsDiv.appendChild(previousList);
  container.appendChild(previousTournamentsDiv);
}


    function renderTeamList() {
    const container = document.getElementById("tab-content");
    container.innerHTML = "";
    
    fetch('teams.json')
      .then(response => {
        if (!response.ok) {
          throw new Error("Failed to load teams.json");
        }
        return response.json();
      })
      .then(data => {
        teams = data.teams;
      // Check if there is team data
      if (!teams || teams.length === 0) {
          container.textContent = "No team data available.";
          return;
      }
      
      // Create a flex container for the teams.
      const teamsFlex = document.createElement("div");
      teamsFlex.style.display = "flex";
      teamsFlex.style.justifyContent = "space-between";
      teamsFlex.style.alignItems = "flex-start"; // Align items at the top so the boxes are even
      teamsFlex.style.flexWrap = "wrap"; // In case screen width is limited
      teamsFlex.style.gap = "10px"; // Optional gap between boxes
      
      // For each team create a flex box.
      teams.forEach(team => {
          const teamBox = document.createElement("div");
          teamBox.style.flex = "1";
          teamBox.style.minWidth = "150px"; // Ensure boxes don't get too narrow.
          teamBox.style.margin = "5px";
          teamBox.style.padding = "10px";
          teamBox.style.border = "1px solid #ccc";
          teamBox.style.borderRadius = "5px";
          teamBox.style.boxSizing = "border-box";
          teamBox.style.display = "flex";
          teamBox.style.flexDirection = "column";
          teamBox.style.alignItems = "stretch";
          
          // Captain name (displayed at the top - left aligned)
          const captain = document.createElement("div");
          captain.textContent = "Captain: " + team.captain;
          captain.style.fontWeight = "bold";
          captain.style.textAlign = "left";
          teamBox.appendChild(captain);
          
          // Win/Lose/Draw record (displayed with a little vertical spacing)
          const record = document.createElement("div");
          record.textContent = "Record: " + team.record;
          record.style.marginTop = "5px";
          record.style.textAlign = "left";
          teamBox.appendChild(record);
          
          // Team members list (vertical list)
          const membersList = document.createElement("ul");
          membersList.style.listStyleType = "disc";
          membersList.style.paddingLeft = "20px";
          membersList.style.marginTop = "10px";
          team.players.forEach(member => {
              const li = document.createElement("div");
              li.textContent = member;
              membersList.appendChild(li);
          });
          teamBox.appendChild(membersList);
          
          teamsFlex.appendChild(teamBox);
      });
      
      container.appendChild(teamsFlex);
        //renderLandingPage();
        //handleURLChange();
        //window.addEventListener('popstate', handleURLChange);
      })
      .catch(error => {
        console.error("Error loading match data:", error);
        document.getElementById('content').innerHTML = `<p style="color: red;">Failed to load match data. Please try again later.</p>`;
      });

}

let filterArc = false;
let filterCav = false;
let filterInf = false;

const filterFac = [false,false,false,false,false,false]

/**
 * Generate aggregated stats for players from match data while applying class filters.
 *
 * @param {number[]} playerIds - Array of player IDs.
 * @param {object} matches - Match data, where matches.matches is an array of match objects.
 * @param {Map} nameToIdMap - A Map from lower-case player names to their IDs.
 * @param {Array} playerNames - An array or object that maps player IDs to [name, ...] (used for display).
 * @param {boolean} filterInf - If true, skip players whose class matches any string in infClasses.
 * @param {boolean} filterCav - If true, skip players whose class matches any string in cavClasses.
 * @param {boolean} filterArc - If true, skip players whose class matches any string in arcClasses.
 * @param {string[]} infClasses - Array of class substrings for infantry.
 * @param {string[]} cavClasses - Array of class substrings for cav.
 * @param {string[]} arcClasses - Array of class substrings for archers.
 * @returns {object[]} A filtered array of aggregated player stats.
 */
 function generatePlayerStats(
  playerIds,
  matches,
  nameToIdMap,
  playerNames
) {
  // Initialize aggregation object.
  const playerStats = {};
  playerIds.forEach(id => {
    if (id === 0) return;
    playerStats[id] = {
      kills: 0,
      classes: [],
      deaths: 0,
      assists: 0,
      dmg: 0,
      tks: 0,
      tdmg: 0,
      tkd: 0,
      rounds: 0,
      wins: 0
    };
  });

  // Process each match and round.
  matches.forEach((match, matchID) => {
      //console.log("MATCH:", matchID)
    match.rounds.forEach((round, roundID) => {
      const { kills, deaths, teamkills, teamkilled, assists, dmg, tdmg, players, classes, teams } = round;
      // Build an array of players we want to include for this round.
      const filteredPlayers = [];
      players.forEach((name, index) => {
        const playerClass = classes[index]; // class for this player in the round
        const playerFac = teams[index] === 0 ? match.faction_1 : match.faction_2;
        // Exit early if any filter is enabled and the player's class matches.
        if (
          (filterInf && infClasses.some(infClass => playerClass.includes(infClass))) ||
          (filterCav && cavClasses.some(cavClass => playerClass.includes(cavClass))) ||
          (filterArc && arcClasses.some(arcClass => playerClass.includes(arcClass)))
          ||
          (filterFac[0] &&  playerFac === factions[0]) ||
          (filterFac[1] &&  playerFac === factions[1]) ||
          (filterFac[2] &&  playerFac === factions[2]) ||
          (filterFac[3] &&  playerFac === factions[3]) ||
          (filterFac[4] &&  playerFac === factions[4]) ||
          (filterFac[5] &&  playerFac === factions[5]) 
        ) {
          return; // Skip this player.
        }
        // Otherwise, include this player's name in the filtered list.
        filteredPlayers.push(name);
        
        const playerId = nameToIdMap.get(name.toLowerCase());
        if (playerId) {
          // Count rounds played.
          playerStats[playerId].rounds += 1;

          // Track the player's class if not already tracked.
          //if (!playerStats[playerId].classes.includes(playerClass)) {
            playerStats[playerId].classes.push(playerClass);
          //}

          if (round.teams[index] === getWinner(round.result)) {
            playerStats[playerId].wins += 1;
          }
        }
      });

      // Now, for stats that depend on loop index and player identity, use filteredPlayers.
      kills.forEach(name => {
        if (filteredPlayers.includes(name)) {
          const playerId = nameToIdMap.get(name.toLowerCase());
          if (playerId) {
            playerStats[playerId].kills += 1;
          }
        }
      });

      deaths.forEach(name => {
        if (filteredPlayers.includes(name)) {
          const playerId = nameToIdMap.get(name.toLowerCase());
          if (playerId) {
            playerStats[playerId].deaths += 1;
          }
        }
      });

      teamkills.forEach(name => {
        if (filteredPlayers.includes(name)) {
          const playerId = nameToIdMap.get(name.toLowerCase());
          if (playerId) {
            playerStats[playerId].tks += 1;
          }
        }
      });

      teamkilled.forEach(name => {
        if (filteredPlayers.includes(name)) {
          const playerId = nameToIdMap.get(name.toLowerCase());
          if (playerId) {
            playerStats[playerId].tkd += 1;
          }
        }
      });

      // For assists, damage, and team damage, the index in the original players array is used.
      //if(!assists) console.log(matchID, match.map, match.faction_1, match.faction_2)
      assists.forEach((value, index) => {
        const name = players[index];
        if (filteredPlayers.includes(name)) {
          const playerId = nameToIdMap.get(name.toLowerCase());
          if (playerId) {
            playerStats[playerId].assists += value;
          }
        }
      });

      dmg.forEach((value, index) => {
        const name = players[index];
        if (filteredPlayers.includes(name)) {
          const playerId = nameToIdMap.get(name.toLowerCase());
          if (playerId) {
            playerStats[playerId].dmg += value;
          }
        }
      });

      tdmg.forEach((value, index) => {
        const name = players[index];
        if (filteredPlayers.includes(name)) {
          const playerId = nameToIdMap.get(name.toLowerCase());
          if (playerId) {
            playerStats[playerId].tdmg += value;
          }
        }
      });
    });
  });

  // Convert stats object into an array for sorting or display.
  let statsArray = playerIds.map(id => ({
    id,
    name: playerNames[playerIds.indexOf(id)][0],
    ...playerStats[id]
  }));

  // Filter out players with all stats as 0.
  statsArray = statsArray.filter(player =>
    player.kills > 0 ||
    player.deaths > 0 ||
    player.assists > 0 ||
    player.dmg > 0 ||
    player.tks > 0 ||
    player.tkd > 0
  );

  return { statsArray, playerStats };
}
// Helper function to count occurrences of a specific classfunction 
function countClassUsage(classes, classGroup){
  if(classGroup){
    return classes.reduce((count, className) => (classGroup.includes(className) ? count + 1 : count), 0);
  }
  
}

// Helper function to convert a numeric value to a gradient color.
// Lowest value returns red (hue 0), highest returns green (hue 120).
function getGradientColor(value, min, max, inv=false) {
  if (max === min) {
    // If all values are the same, just return a neutral green.
    return "hsl(120, 100%, 40%)";
  }
  let ratio = (value - min) / (max - min);
  if (inv) {
    // Invert the ratio so that higher values become lower visually.
    ratio = 1 - ratio;
  }
  const hue = 120 * ratio; // 0 (red) for lowest, 120 (green) for highest.
  return `hsl(${hue}, 100%, 40%)`;
}

function renderPlayersList(s1, s2, title="All Player Stats") {
    const container = document.getElementById("tab-content");
    container.innerHTML = "";  // Clear previous content

    const statsTitle = document.createElement("h2");
    statsTitle.textContent = title;
    container.appendChild(statsTitle)
        // Step 1: Map all player names to their unique IDs
        const nameToIdMap = new Map();
        playerIds.forEach((id, index) => {
          if (id === 0 ) return;
            playerNames[index].forEach(name => {
                nameToIdMap.set(name.toLowerCase(), id); // Use lowercase for case-insensitive mapping
            });
        });

        let { statsArray, playerStats } = generatePlayerStats(playerIds, matches.slice(s1, s2), nameToIdMap, playerNames);
        var playersContainer = document.createElement("div");
        //playersContainer.id = "players-container";
        playersContainer.style.paddingLeft = "0";


        // Default sort by kills (high to low)
        let currentSortColumn = "kills";
        let currentSortDivisor = "none";
        let currentSortDirection = "desc"; // "desc" or "asc"

        // Function to render the table
        const renderTable = () => {
          playersContainer.innerHTML = ""; // Clear previous content

            //filters 
            const filterContainer = document.createElement("div");
            const filterH = document.createElement("div");
            filterH.textContent = "Filters";
            filterH.style.marginTop = "0";
            filterH.style.paddingBottom = "10px";
            filterH.style.paddingLeft = "10px";
            filterH.style.paddingRight = "10px";
            filterH.style.maxWidth = "120px";
            filterH.style.borderBottom = "1px solid #ccc"
            filterContainer.appendChild(filterH)

                // Create the container for the faction icons
                const factionContainer = document.createElement("div");
                factionContainer.style.display = "flex";
                factionContainer.style.flexWrap = "wrap"; // Allow wrapping to stack icons
                factionContainer.style.justifyContent = "center"; // Center the icons
                factionContainer.style.gap = "10px"; // Add spacing between icons
                factionContainer.style.padding = "10px"; // Optional padding
                factionContainer.style.maxWidth = "120px"
                factionContainer.style.borderTop = "1px solid #ccc"
                factionContainer.style.borderBottom = "1px solid #ccc"

                // Loop through the factions array to generate icons
                factions.forEach((faction, index) => {
                  // Create an icon for each faction
                  const factionIcon = document.createElement("img");
                  factionIcon.style.cursor = "pointer";
                  factionIcon.style.width = "30px"; // Adjust size as needed
                  factionIcon.style.height = "30px"; // Adjust size as needed
                  factionIcon.style.objectFit = "contain"; // Ensure the icon fits well within its boundaries
                  factionIcon.src = `assets/img/${facIcons[index]}.png`; // Set the image source dynamically
                  factionIcon.alt = faction; // Set an alt attribute for accessibility
                  factionIcon.style.filter = `grayscale(${+filterFac[index]})`;


                  // Add click event for toggling the filter
                  factionIcon.onclick = () => {
                    filterFac[index] = !filterFac[index];
                    if(filterFac.every(x => {return x == true})) {filterFac.fill(false)}
                    // Regenerate player stats and re-render the table
                    ({ statsArray, playerStats } = generatePlayerStats(playerIds, matches.slice(s1, s2), nameToIdMap, playerNames));
                    renderTable();

                    // Update icon appearance based on filter state (e.g., grayscale)
                    //factionIcon.style.filter = `grayscale(${+filterFac[index]})`;
                    // console.log(`Faction filter for ${faction}:`, factionFilters[faction]);
                  };

                  // Append the icon to the container
                  factionContainer.appendChild(factionIcon);
                });
                
                const infclass = document.createElement("img");
                infclass.style.cursor = "pointer";
                infclass.onclick = () => {
                  filterInf = !filterInf;
                  if(filterInf && filterCav && filterArc) {
                    filterInf = false;
                    filterCav = false;
                    filterArc = false;
                  }
                  ({ statsArray, playerStats  } = generatePlayerStats(playerIds, matches.slice(s1, s2), nameToIdMap, playerNames));
                  renderTable();
                  //console.log("Inf filter:", filterInf)
                }
                infclass.style.filter = `grayscale(${+filterInf})`;
                infclass.src = "assets/img/class_inf.png";
                infclass.alt = "inf";
                infclass.height = infclass.naturalHeight * 0.5;
                infclass.onload = () => {
                  infclass.height = infclass.naturalHeight * 0.5;
                }
                infclass.style.alignItems = "left;"
                infclass.style.paddingLeft = "8px";
                //infclass.style.borderBottom = "1px solid #ccc"
                filterContainer.appendChild(infclass);

                const cavclass = document.createElement("img");
                cavclass.style.cursor = "pointer";
                cavclass.onclick = () => {
                  filterCav = !filterCav;
                  if(filterInf && filterCav && filterArc) {
                    filterInf = false;
                    filterCav = false;
                    filterArc = false;
                  }
                  ({ statsArray, playerStats  } = generatePlayerStats(playerIds, matches.slice(s1, s2), nameToIdMap, playerNames));
                  renderTable();
                  //console.log("Cav filter:", filterCav)
                }
                cavclass.style.filter = `grayscale(${+filterCav})`;
                cavclass.src = "assets/img/class_cav.png";
                cavclass.alt = "cav";
                cavclass.height = cavclass.naturalHeight * 0.5;
                cavclass.onload = () => {
                  cavclass.height = cavclass.naturalHeight * 0.5;
                }
                cavclass.style.alignItems = "left;"
                cavclass.style.paddingLeft = "8px";
                //cavclass.style.borderBottom = "1px solid #ccc"
                filterContainer.appendChild(cavclass);

                const arcclass = document.createElement("img");
                arcclass.style.cursor = "pointer";
                arcclass.onclick = () => {
                  filterArc = !filterArc;
                  if(filterInf && filterCav && filterArc) {
                    filterInf = false;
                    filterCav = false;
                    filterArc = false;
                  }
                  ({ statsArray, playerStats } = generatePlayerStats(playerIds, matches.slice(s1, s2), nameToIdMap, playerNames));
                  renderTable();
                  //console.log("Archer filter:", filterArc)
                }
                arcclass.style.filter = `grayscale(${+filterArc})`;
                arcclass.src = "assets/img/class_arc.png";
                arcclass.alt = "arc";
                arcclass.height = arcclass.naturalHeight * 0.5;
                arcclass.onload = () => {
                  arcclass.height = arcclass.naturalHeight * 0.5;
                }
                arcclass.style.alignItems = "left;"
                arcclass.style.paddingLeft = "8px";
                //arcclass.style.borderBottom = "1px solid #ccc"
                filterContainer.appendChild(arcclass);

                filterContainer.appendChild(factionContainer);
              playersContainer.appendChild(filterContainer);

            const table = document.createElement("table");
            table.style.width = "100%";
            table.style.borderCollapse = "collapse";

            const columns = ["Player Name", "Kills", "Deaths", "Assists", "Dmg", "TKs", "TDmg", "TKd", "Rounds", "Wins"];
              if (currentSortDivisor !== "none") {
                // Filter out players with all stats as 0
                statsArray = statsArray.filter(player =>
                player[currentSortDivisor.toLowerCase()] !== 0
                && player[currentSortDivisor.toLowerCase()] !== undefined
                && (player.kills > 0 ||
                    player.deaths > 0 ||
                    player.assists > 0 ||
                    player.dmg > 0 ||
                    player.tks > 0 ||
                    player.tked > 0)
                );
              //const columnIndex = columns.indexOf(currentSortDivisor.toLowerCase())
                statsArray = statsArray.map(player => {
                  const divider = player[currentSortDivisor.toLowerCase()]; // Value to divide by
                  // Create a new object with divided values for other stats
                  const dividedPlayer = { ...player };
                  columns.forEach(stat => {
                      if (stat !== "Player Name" && stat !== currentSortColumn.toLowerCase() && stat !== currentSortDivisor) {
                          dividedPlayer[stat.toLowerCase()] = 
                              (player[stat.toLowerCase()] / divider).toFixed(2); // Perform division
                      }
                  });
                  return dividedPlayer;
                });
                statsArray = statsArray.filter(player =>
                player[currentSortDivisor.toLowerCase()] !== 0
                && player[currentSortDivisor.toLowerCase()] !== undefined
                && ((player.kills !== Infinity && player.kills > 0) ||
                    player.deaths > 0 ||
                    (player.assists < Infinity && player.assists > 0) ||
                    (player.dmg < Infinity && player.dmg > 0) ||
                    player.tks > 0 ||
                    player.tked > 0)
                );
              }
            // Sort the stats array
            statsArray.sort((a, b) => {
                const valueA = a[currentSortColumn];
                const valueB = b[currentSortColumn];

                if (currentSortDirection === "desc") {
                    return valueB - valueA;
                } else {
                    return valueA - valueB;
                }
            });

            // Create table header
            const headerRow = document.createElement("tr");
            columns.forEach(column => {
                const th = document.createElement("th");
                th.textContent = column;
                th.style.borderBottom = "1px solid #ccc";
                th.style.padding = "8px";
                th.style.textAlign = "left";
                // Add click event for sorting
              if (column !== "Player Name"){
                let ignore = false;
                th.style.cursor = "pointer";
                // Add a span for the clickable division symbol
                const divisionSpan = document.createElement("span");
                divisionSpan.textContent = " Ã·"; 
                divisionSpan.style.marginLeft = "5px"; 
                divisionSpan.style.opacity ="1"; 
                divisionSpan.style.display = "inline-block"; 
                divisionSpan.style.fontSize = "1.45em";
                divisionSpan.style.textAlign = "center";
                if (currentSortColumn === column.toLowerCase())th.style.color = currentSortDirection === "asc" ? "red" : "green";
                divisionSpan.style.color = "#C7C7C6";
                //divisionSpan.style.opacity = "0";
              //} else {
                //divisionSpan.style.opacity = "1";
                
                if (currentSortDivisor == column) divisionSpan.style.color = "green";
                divisionSpan.style.cursor = "pointer";
                
                divisionSpan.onclick = () => {
                  ignore = true;
                  //duplicated code -- reset stats 
                  statsArray = playerIds.map(id => ({
                      id,
                      name: playerNames[playerIds.indexOf(id)][0],
                      ...playerStats[id]
                  }));
                  
                  const columnIndex = columns.indexOf(column)
                  // Filter out players with all stats as 0
                  statsArray = statsArray.filter(player =>
                  player[columns[columnIndex].toLowerCase()] !== 0
                  && player[columns[columnIndex].toLowerCase()] !== undefined
                  && (player.kills > 0 ||
                      player.deaths > 0 ||
                      player.assists > 0 ||
                      player.dmg > 0 ||
                      player.tks > 0 ||
                      player.tked > 0)
                  );
                  if(currentSortDivisor !== column) {
                    currentSortDivisor = column;
                    } else {
                      currentSortDivisor = "none";
                      //duplicated code -- reset stats 
                      statsArray = playerIds.map(id => ({
                          id,
                          name: playerNames[playerIds.indexOf(id)][0],
                          ...playerStats[id]
                      }));
                      
                      const columnIndex = columns.indexOf(column)
                      // Filter out players with all stats as 0
                      statsArray = statsArray.filter(player =>
                          player.kills > 0 ||
                          player.deaths > 0 ||
                          player.assists > 0 ||
                          player.dmg > 0 ||
                          player.tks > 0 ||
                          player.tked > 0
                      );
                      // Re-render the table
                      renderTable();
                    };
                    // Sort the stats array
                    statsArray.sort((a, b) => {
                        const valueA = a[currentSortColumn];
                        const valueB = b[currentSortColumn];

                        if (currentSortDirection === "desc") {
                            return valueB - valueA;
                        } else {
                            return valueA - valueB;
                        }
                    });
                    renderTable();
                  };
                th.appendChild(divisionSpan);
                th.onclick = () => {
                  if(!ignore){
                    if (currentSortColumn === column.toLowerCase()) {
                          // Toggle sort direction
                        currentSortDirection = currentSortDirection === "desc" ? "asc" : "desc";
                    } else {
                        // Change sort column
                        currentSortColumn = column.toLowerCase();
                        currentSortDirection = "desc"; 
                        if(currentSortDivisor == currentSortColumn) {
                          currentSortDivisor = "none";
                        }
                    }

      
                    //duplicated code -- reset stats 
                    statsArray = playerIds.map(id => ({
                        id,
                        name: playerNames[playerIds.indexOf(id)][0],
                        ...playerStats[id]
                    }));
                    
                    const columnIndex = columns.indexOf(column)
                    // Filter out players with all stats as 0
                    statsArray = statsArray.filter(player =>
                    player[columns[columnIndex].toLowerCase()] !== 0
                    && player[columns[columnIndex].toLowerCase()] !== undefined
                    && (player.kills > 0 ||
                        player.deaths > 0 ||
                        player.assists > 0 ||
                        player.dmg > 0 ||
                        player.tks > 0 ||
                        player.tked > 0)
                    );
                    // Re-render the table
                    renderTable();
                };
                ignore = false;
              }
              } 

        
                headerRow.appendChild(th);
            });
            table.appendChild(headerRow);

            const divisorIndex = columns.indexOf(currentSortDivisor);
            const numCols = columns.length;

            // Initialize min and max arrays for each column.
            const minValues = new Array(numCols).fill(Infinity);
            const maxValues = new Array(numCols).fill(-Infinity);

            // Pre-compute min and max for each numeric column (ignoring the divisor)
            // We assume each player's stats are collected in the same order as columns.
            statsArray.forEach((player) => {
              // Construct an array with all column values.
              const rowValues = [
                player.name,
                player.kills,
                player.deaths,
                player.assists,
                player.dmg,
                player.tks,
                player.tdmg,
                player.tkd,
                player.rounds,
                player.wins
              ];

              rowValues.forEach((value, idx) => {
                // Skip divisor column (or any non-numeric field like 'name', if applicable)
                if (idx === divisorIndex) return;
                const num = parseFloat(value);
                if (!isNaN(num)) {
                  minValues[idx] = Math.min(minValues[idx], num);
                  maxValues[idx] = Math.max(maxValues[idx], num);
                }
              });
            });
            // Populate table rows
            statsArray.forEach((player, index) => {
                const row = document.createElement("tr");
                [
                    player.name,
                    //player.class,
                    player.kills,
                    player.deaths,
                    player.assists,
                    player.dmg,
                    player.tks,
                    player.tdmg,
                    player.tkd,
                    player.rounds,
                    player.wins
                ].forEach((value, valueIndex) => {
                    const td = document.createElement("td");
                    if (value === player.name){
                      const nameSpan = document.createElement("span");
                      nameSpan.textContent = `${index + 1}. ` + value;
                      nameSpan.style.cursor = "pointer";
                      nameSpan.onclick = () => {
                        // console.log("Player..!", playerIds.indexOf(index))
                        updateURLToPlayer(nameToIdMap.get(value.toLowerCase()))
                      }
                      
                      td.appendChild(nameSpan);
                      // Count occurrences for each class
                      const infCount = countClassUsage(player.classes, infClasses);
                      const cavCount = countClassUsage(player.classes, cavClasses);
                      const arcCount = countClassUsage(player.classes, arcClasses);
                      //console.log(value, infCount, cavCount, arcCount)
                      
                      // Infantry Icon with Count
                      if (infCount > 0) {
                        const infContainer = document.createElement("div");
                        infContainer.style.position = "relative";
                        infContainer.style.display = "inline-block";
                        infContainer.style.marginLeft = "5px";

                        const infclass = document.createElement("img");
                        infclass.src = "assets/img/class_inf.png";
                        infclass.alt = "inf";
                        infclass.height = infclass.naturalHeight * 0.5;
                        infclass.onload = () => {
                          infclass.height = infclass.naturalHeight * 0.5;
                          infclass.style.display = "block";
                        }

                        const infCountSpan = document.createElement("span");
                        infCountSpan.textContent = infCount;
                        infCountSpan.style.position = "absolute";
                        infCountSpan.style.bottom = "-2px"; // Slightly below the image
                        infCountSpan.style.left = "60%";
                        infCountSpan.style.transform = "translateX(-50%)";
                        infCountSpan.style.fontSize = "10px"; // Small font
                        infCountSpan.style.color = "#d1d1d1";

                        infContainer.appendChild(infclass);
                        infContainer.appendChild(infCountSpan);
                        td.appendChild(infContainer);
                      }

                      // Cavalry Icon with Count
                      if (cavCount > 0) {
                        const cavContainer = document.createElement("div");
                        cavContainer.style.position = "relative";
                        cavContainer.style.display = "inline-block";
                        cavContainer.style.marginLeft = "5px";

                        const cavclass = document.createElement("img");
                        cavclass.src = "assets/img/class_cav.png";
                        cavclass.alt = "cav";
                        cavclass.height = cavclass.naturalHeight * 0.5;
                        cavclass.onload = () => {
                          cavclass.height = cavclass.naturalHeight * 0.5;
                          cavclass.style.display = "block";
                        }

                        const cavCountSpan = document.createElement("span");
                        cavCountSpan.textContent = cavCount;
                        cavCountSpan.style.position = "absolute";
                        cavCountSpan.style.bottom = "-2px"; // Slightly below the image
                        cavCountSpan.style.left = "60%";
                        cavCountSpan.style.transform = "translateX(-50%)";
                        cavCountSpan.style.fontSize = "10px"; // Small font
                        cavCountSpan.style.color = "#d1d1d1";

                        cavContainer.appendChild(cavclass);
                        cavContainer.appendChild(cavCountSpan);
                        td.appendChild(cavContainer);
                      }

                      // Archer Icon with Count
                      if (arcCount > 0) {
                        const arcContainer = document.createElement("div");
                        arcContainer.style.position = "relative";
                        arcContainer.style.display = "inline-block";
                        arcContainer.style.marginLeft = "5px";

                        const arcclass = document.createElement("img");
                        arcclass.src = "assets/img/class_arc.png";
                        arcclass.alt = "arc";
                        arcclass.height = arcclass.naturalHeight * 0.5;
                        arcclass.onload = () => {
                          arcclass.height = arcclass.naturalHeight * 0.5;
                          arcclass.style.display = "block";
                        }
                        

                        const arcCountSpan = document.createElement("span");
                        arcCountSpan.textContent = arcCount;
                        arcCountSpan.style.position = "absolute";
                        arcCountSpan.style.bottom = "-2px"; // Slightly below the image
                        arcCountSpan.style.left = "60%";
                        arcCountSpan.style.transform = "translateX(-50%)";
                        arcCountSpan.style.fontSize = "10px"; // Small font
                        arcCountSpan.style.color = "#d1d1d1";

                        arcContainer.appendChild(arcclass);
                        arcContainer.appendChild(arcCountSpan);
                        td.appendChild(arcContainer);
                      }  
                    } else {
                      if(valueIndex !== columns.indexOf(currentSortDivisor)) {
                        // Try converting the value to a number.
                        const num = parseFloat(value);
                        // Only color the cell if itâ€™s a valid number.
                        if (!isNaN(num)) {
                          const inverted = valueIndex == columns.indexOf("Deaths") || valueIndex == columns.indexOf("TKs") || valueIndex == columns.indexOf("TKd") || valueIndex == columns.indexOf("TDmg"); 
                          td.style.color = getGradientColor(num, minValues[valueIndex], maxValues[valueIndex], inverted);
                        }
                        td.textContent = value;
                      } else {
                        td.textContent = "/" + value;
                      }
                      td.style.padding = "8px";
                    }
                    
                    td.style.borderBottom = "1px solid #ccc";
                    row.appendChild(td);
                });
                table.appendChild(row);
            });

            playersContainer.appendChild(table);
            container.appendChild(playersContainer);
        };

        // Initial render
        statsArray.sort((a, b) => b.kills - a.kills); // Default to kills high-to-low
        renderTable();
    // .catch(error => {
    //     container.innerHTML = "<p style='color:red;'>Error loading data: " + error.message + "</p>";
    // });
}

    // Example: Render a list of scrims.
    function renderScrimList() {
      const container = document.getElementById("tab-content");
      if (scrims && scrims.length > 0) {
        scrims.forEach((scrim, index) => {
          const p = document.createElement("p");
          p.textContent = `Scrim ${index}: [${scrim.join(", ")}]`;
          p.style.cursor = "pointer";
          // Optionally, clicking the scrim updates the URL and renders the scrim view.
          p.addEventListener("click", () => {
            updateURLToScrim(index);
          });
          container.appendChild(p);
        });
      } else {
        container.textContent = "No scrims available.";
      }
    }


function renderMatchList() {
  const container = document.getElementById("tab-content");
  container.innerHTML = ""; // Clear any existing content

  if (matches && matches.length > 0) {
    // Reverse the matches array
    const reversedMatches = matches.slice().reverse(); // Create a reversed copy of the matches array

    // Loop through the reversed array
    reversedMatches.forEach((match, reversedIndex) => {
      //if (reversedIndex >= reversedMatches.length - 45) return; 

      // Calculate the correct index in the original `matches` array
      const ogindex= matches.length - 1 - reversedIndex;

      // Create a container for the match
      const matchDiv = document.createElement("div");
      matchDiv.style.borderTop = "1px solid #ccc";
      matchDiv.style.marginTop = "40px";
      matchDiv.style.padding = "10px";
      matchDiv.style.cursor = "pointer";
      matchDiv.style.display = "flex";
      matchDiv.style.justifyContent = "space-between"; // Align teams on either side
      matchDiv.style.alignItems = "center";
      matchDiv.style.flexWrap = "wrap";

      // Extract scores (team0 and team1)
      const scoreParts = match.score.split("(");
      const team0Score = scoreParts[0].split("-")[0].trim(); // Extract Team 0's score
      const team1Score = scoreParts[0].split("-")[1].trim(); // Extract Team 1's score
      // Initialize objects to track top players for each team
      const topPlayers = { team0: { name: "", kills: 0, class: "" }, team1: { name: "", kills: 0, class: "" } };

      // Initialize class lists for each team
      const teamClasses = { team0: [], team1: [] };

      // Create a dictionary to count kills and teamkills
      const playerStats = {};

      // Iterate through all rounds and process player statistics
      match.rounds.forEach((round, rid) => {
        //console.log("MATCHES?")
        round.teams.forEach((team, i) => {
          //console.log("ROUNDS?")
          const playerName = round.players[i]; // Get player's name
          const playerClass = round.classes[i]; // Get player's class

          // Initialize stats for player if not already present
          if (!playerStats[playerName]) {
            playerStats[playerName] = { kills: 0, teamkills: 0, class: playerClass };
          }

          // Increment kills and teamkills for the player
          const kills = round.kills.filter((name) => name === playerName).length;
          const teamkills = round.teamkills.filter((name) => name === playerName).length;

          playerStats[playerName].kills += kills;
          playerStats[playerName].teamkills += teamkills;

          // Add the player's class to their respective team
          if (team === 0 && rid === match.rounds.length-1) {
            teamClasses.team0.push(playerClass);
          } else if (team === 1 && rid === match.rounds.length-1) {
            teamClasses.team1.push(playerClass);
          }
        });
      });

      // Calculate the top player for each team based on kills - teamkills
      Object.keys(playerStats).forEach((playerName) => {
        const total = playerStats[playerName].kills - playerStats[playerName].teamkills;
        const team = match.rounds[0].teams[match.rounds[0].players.indexOf(playerName)]; // Determine the team for the player

        if (team === 0 && total > topPlayers.team0.kills) {
          topPlayers.team0 = { name: playerName, kills: total, class: playerStats[playerName].class };
        } else if (team === 1 && total > topPlayers.team1.kills) {
          topPlayers.team1 = { name: playerName, kills: total, class: playerStats[playerName].class };
        }
      });
      //console.log("TOP KILLAS", topPlayers)
      // Team 0 (Left Side)
      const team0Div = document.createElement("div");
      team0Div.style.flex = "1";
      team0Div.style.textAlign = "center";
      team0Div.style.display = "flex";
      team0Div.style.flexDirection = "column";
      team0Div.style.flexWrap = "wrap";
      team0Div.style.alignItems = "center";
      team0Div.style.justifyContent = "flex-end";

      
      const team0Image = document.createElement("div");
      team0Image.style.textAlign = "center";
      team0Image.style.display = "flex";
      team0Image.style.flexDirection = "row";
      team0Image.style.flexWrap = "wrap";
      for(let i = 0; i < team0Score; i++){
        const fac1Img = document.createElement("img");
        const flag1 = facIcons[factions.indexOf(match.faction_1)];
        fac1Img.src = `assets/img/${flag1}.png`;
        fac1Img.height = fac1Img.naturalHeight * 0.5;
        fac1Img.onload = () => {
          fac1Img.height = fac1Img.naturalHeight * 0.5;
        }
        fac1Img.style.display = "block";
        fac1Img.style.padding = "10px";
        fac1Img.style.margin = "0 auto";
        team0Image.appendChild(fac1Img);
      }
      team0Div.appendChild(team0Image);

      const team0Frag = document.createElement("div");
      team0Frag.style.marginTop = "10px";
      team0Frag.style.display = "flex";
      team0Frag.style.flexWrap = "wrap";
      team0Frag.style.justifyContent = "center";
      team0Frag.style.alignItems = "flex-end";
      team0Frag.textContent = topPlayers.team0.name + ` (${topPlayers.team0.kills} kills)`;
      team0Div.appendChild(team0Frag);

      // Class list images for Team 0
      const team0Classes = document.createElement("div");
      team0Classes.style.marginTop = "10px";
      team0Classes.style.display = "flex";
      team0Classes.style.flexWrap = "wrap";
      team0Classes.style.justifyContent = "center";
      team0Classes.style.alignItems = "flex-end";
      teamClasses.team0.forEach((className) => {
        setClassImage(className, team0Classes); // Use the reusable function
      });
      team0Div.appendChild(team0Classes);

      // Team 1 (Right Side)
      const team1Div = document.createElement("div");
      team1Div.style.flex = "1";
      team1Div.style.textAlign = "center";
      team1Div.style.display = "flex";
      team1Div.style.flexDirection = "column";
      team1Div.style.alignItems = "center";
      team1Div.style.justifyContent = "flex-end";

      // Placeholder for faction image (if any)
      const team1Image = document.createElement("div");
      team1Image.style.textAlign = "center";
      team1Image.style.display = "flex";
      team1Image.style.flexDirection = "row";
      team1Image.style.flexWrap = "wrap";
      for(let i = 0; i < team1Score; i++){
        const fac2Img = document.createElement("img");
        const flag2 = facIcons[factions.indexOf(match.faction_2)];
        fac2Img.src = `assets/img/${flag2}.png`;
        fac2Img.height = fac2Img.naturalHeight * 0.5;
        fac2Img.onload = () => {
          fac2Img.height = fac2Img.naturalHeight * 0.5;
        }
        fac2Img.style.display = "block";
        fac2Img.style.padding = "10px";
        fac2Img.style.margin = "0 auto";
        team1Image.appendChild(fac2Img);
      }
      team1Div.appendChild(team1Image);

      const team1Frag = document.createElement("div");
      team1Frag.style.marginTop = "10px";
      team1Frag.style.display = "flex";
      team1Frag.style.flexWrap = "wrap";
      team1Frag.style.justifyContent = "center";
      team1Frag.style.alignItems = "flex-end";
      team1Frag.textContent = topPlayers.team1.name + ` (${topPlayers.team1.kills} kills)`;
      team1Div.appendChild(team1Frag);

      // Class list images for Team 1
      const team1Classes = document.createElement("div");
      team1Classes.style.marginTop = "10px";
      team1Classes.style.display = "flex";
      team1Classes.style.flexWrap = "wrap";
      team1Classes.style.justifyContent = "center";
      team1Classes.style.alignItems = "flex-end";
      teamClasses.team1.forEach((className) => {
        setClassImage(className, team1Classes, 1); // Use the reusable function
      });
      team1Div.appendChild(team1Classes);

      
      // Center Section (Map and Score)
      const centerDiv = document.createElement("div");
      centerDiv.style.flex = "1";
      centerDiv.style.textAlign = "center";
      centerDiv.style.alignItems = "center";

      // Create a container for the thumbnail and text overlay
      const mapContainer = document.createElement("div");
      mapContainer.style.position = "relative"; // Enables positioning of text relative to the image
      mapContainer.style.display = "inline-block"; // Ensures proper layout

      // Map thumbnail image
      const mapThumbn = document.createElement("img");
      const thmbSrc = match.map.toLowerCase().replaceAll(" ", "_").replaceAll("'","");

      mapThumbn.src = `assets/img/tbn_${thmbSrc}.png`
      mapThumbn.alt = "";
      
      // mapThumbn.style.width = "400px"; // Adjust width as needed
      // mapThumbn.style.height = "auto"; // Maintain aspect ratio
      mapContainer.appendChild(mapThumbn);

      // Map name text overlay
      const mapName = document.createElement("span");
      mapName.style.position = "absolute";
      mapName.style.top = "10px"; // Position near the top of the image
      mapName.style.left = "50%"; // Center horizontally
      mapName.style.transform = "translateX(-50%)"; // Align text to the center
      mapName.style.color = "white"; // Set text color for visibility
      mapName.style.fontWeight = "bold";
      mapName.style.fontSize = "32px"; // Adjust font size as needed
      mapName.style.textShadow = "2px 2px 4px rgba(0, 0, 0, 0.7)"; // Add text shadow for readability
      mapName.style.whiteSpace = "nowrap"; 
      mapName.textContent = match.map;
      mapContainer.appendChild(mapName);

      // Score with flag icons overlay
      const scoreContainer = document.createElement("div");
      scoreContainer.style.position = "absolute"; // Overlay on top of the image
      scoreContainer.style.top = "75%"; // C
      scoreContainer.style.left = "50%"; // Center horizontally
      scoreContainer.style.transform = "translate(-50%, -50%)"; // Offset for perfect centering
      scoreContainer.style.display = "flex";
      scoreContainer.style.alignItems = "center";
      scoreContainer.style.justifyContent = "center";
      scoreContainer.style.gap = "10px"; // Space between elements

      // Flag 1 (Team 0)
      const fac1Img = document.createElement("img");
      const flag1 = facIcons[factions.indexOf(match.faction_1)];
      fac1Img.src = `assets/img/${flag1}.png`;
      fac1Img.height = fac1Img.naturalHeight * 0.35;
      fac1Img.onload = () => {
        fac1Img.height = fac1Img.naturalHeight * 0.35;
      }
      scoreContainer.appendChild(fac1Img);

      // Score Text
      const scoreDiv = document.createElement("span");
      scoreDiv.style.fontSize = "32px"; // Adjust font size as needed
      scoreDiv.style.fontWeight = "bold";
      scoreDiv.style.color = "white"; // Ensure it stands out on the image
      scoreDiv.style.textShadow = "2px 2px 4px rgba(0, 0, 0, 0.7)"; // Add shadow for readability
      scoreDiv.textContent = `${team0Score} - ${team1Score}`;
      scoreContainer.appendChild(scoreDiv);

      // Flag 2 (Team 1)
      const fac2Img = document.createElement("img");
      const flag2 = facIcons[factions.indexOf(match.faction_2)];
      fac2Img.src = `assets/img/${flag2}.png`;
      fac2Img.height = fac2Img.naturalHeight * 0.35;
      fac2Img.onload = () => {
        fac2Img.height = fac2Img.naturalHeight * 0.35;
      }
      scoreContainer.appendChild(fac2Img);

      // Add the scoreContainer to the mapContainer (or centerDiv if preferred)
      mapContainer.appendChild(scoreContainer);


      // Append the container to the center div
      centerDiv.appendChild(mapContainer);

      // // Factions vs text
      // const faction1Vs = document.createElement("h2");
      // faction1Vs.style.margin = "1px";
      // faction1Vs.textContent = `${match.faction_1}`;
      // centerDiv.appendChild(faction1Vs);
      // const factionsVs = document.createElement("div");
      // factionsVs.style.margin = "1px";
      // factionsVs.textContent = `vs`;
      // centerDiv.appendChild(factionsVs);
      // const faction2Vs = document.createElement("h2");
      // faction2Vs.style.margin = "1px";
      // faction2Vs.textContent = `${match.faction_2}`;
      // centerDiv.appendChild(faction2Vs);

      // Append the three sections to the main match container
      matchDiv.appendChild(team0Div); // Left side (Team 0)
      matchDiv.appendChild(centerDiv); // Middle (Map name and Score)
      matchDiv.appendChild(team1Div); // Right side (Team 1)

      // Add click event to update the URL and view match stats
      matchDiv.addEventListener("click", () => {
        updateURLToMatch(ogindex);
      });

      // Append the match container to the tab content
      container.appendChild(matchDiv);
    });
  } else {
    container.textContent = "No matches available.";
  }
}
//
function renderHalfList(halves) {
  const container = document.getElementById("tab-content");
  container.innerHTML = ""; // Clear existing content


  // Reverse the halves array and skip the first 23 in the original order
  const startingIndex = 23+1; // Number of halves to skip in original order
  const halvesToRender = halves.slice(startingIndex); // Adjust for skipping
  const reversedHalves = halvesToRender.slice().reverse(); // Reverse the halves array

  let lastTimestamp = null;
  let pickupParties = 1;
  let partyFirstMatch = reversedHalves[0][0]+1;
  let pickupMatches = [];

    
    //Season aggregate
    //hardcoding this for the moment - this will be the ongoing season aggregate once another match is played
    //if (halfs[ogindex][1] === pickupSeasons[1][1]) {
          const wrapUp = document.createElement("h1");
          wrapUp.textContent = `${pickupSeasons[pickupSeasons.length-1][2]} (ONGOING)`;
          wrapUp.style.cursor = "pointer";
          wrapUp.style.paddingBottom = "20px";
          wrapUp.style.borderBottom = "1px solid #ccc";
          wrapUp.addEventListener("click", () => {
            renderLandingPage("players");
            renderPlayersList(pickupSeasons[pickupSeasons.length-1][0], pickupSeasons[pickupSeasons.length-1][1], `${pickupSeasons[pickupSeasons.length-1][2]} WRAP UP`)
          });
          container.appendChild(wrapUp);
    //}
    
  const lastPickup = document.createElement("h1");
  lastPickup.id = "pickup-0"
  lastPickup.textContent = `PICKUP PARTY #${pickupParties + 1}`;
  lastPickup.style.cursor = "pointer";
  lastPickup.style.paddingBottom = "20px";
  lastPickup.style.borderBottom = "1px solid #ccc";
  container.appendChild(lastPickup);
  //console.log("LASTPICKUP", halfs[startingIndex][0], partyFirstMatch);

  reversedHalves.forEach((half, reversedIndex) => {

    const ogindex = halfs.length - 1 - reversedIndex;
    const curTimestamp = matches[half[0]].start_time;
    //let hr = "0px";

    //past seasons
    //console.log(halfs[ogindex][1], pickupSeasons[0][1])
    for(let i=0; i<pickupSeasons.length-1; i++){
      if (halfs[ogindex][1] === pickupSeasons[i][1]) {
        const snwrapUp = document.createElement("h1");
            snwrapUp.textContent = `${pickupSeasons[i][2]} WRAP UP`;
            snwrapUp.style.cursor = "pointer";
            snwrapUp.style.paddingBottom = "20px";
            snwrapUp.style.borderBottom = "1px solid #ccc";
            snwrapUp.addEventListener("click", () => {
              renderLandingPage("players");
              renderPlayersList(pickupSeasons[i][0], pickupSeasons[i][1], `${pickupSeasons[i][2]} WRAP UP`)
            });
            container.appendChild(snwrapUp);
      }
    }

    //Daily aggregate
    if (lastTimestamp) {
            // Calculate the time difference in seconds
            const lastTimeParts = lastTimestamp.split(":").map(Number); // Convert hh:mm:ss to [hh, mm, ss]
            const currentTimeParts = curTimestamp.split(":").map(Number);

            const lastSeconds = lastTimeParts[0] * 3600 + lastTimeParts[1] * 60 + lastTimeParts[2];
            const currentSeconds = currentTimeParts[0] * 3600 + currentTimeParts[1] * 60 + currentTimeParts[2];

            // Handle midnight rollover
            const timeDifference = lastSeconds >= currentSeconds
                ? lastSeconds - currentSeconds // Normal difference
                : lastSeconds + (86400 - currentSeconds); // Crossing midnight

            if (timeDifference > 6 * 3600) { // More than 6 hours
                // const lineBreak = document.createElement("hr"); // Create a visual separator (line break)
                //lineBreak.style.border = "1px solid #ccc";
                // container.appendChild(lineBreak);
                //hr = "1px solid #ccc";
                const pickupParty = document.createElement("h1");
                pickupParty.textContent = `PICKUP PARTY`;
                pickupParty.id = `pickup-${pickupParties}`;
                pickupParty.style.cursor = "pointer";
                pickupParty.style.paddingBottom = "20px";
                pickupParty.style.borderBottom = "1px solid #ccc";
                pickupParties++
                container.appendChild(pickupParty);

                //console.log(`MATCHES FOR PICKUP ${pickupParties}:`, reversedHalves[reversedIndex-1][0], partyFirstMatch)
                pickupMatches.push([reversedHalves[reversedIndex-1][0], partyFirstMatch]);
                partyFirstMatch = reversedHalves[reversedIndex][0]+1;
            }
        }
    lastTimestamp = curTimestamp;


    // Extract matches for the half
    const match0 = matches[half[0]]; // First match in the half
    const match1 = matches[half[1]]; // Second match in the half

    // Create a container for the half
    const halfDiv = document.createElement("div");
    halfDiv.style.borderBottom = "1px solid #ccc";
    //halfDiv.style.borderTop = `${hr}`;
    halfDiv.style.marginTop = "40px";
    halfDiv.style.padding = "10px";
    halfDiv.style.cursor = "pointer";
    halfDiv.style.display = "flex";
    halfDiv.style.justifyContent = "space-between"; // Align teams on either side
    halfDiv.style.alignItems = "center";
    halfDiv.style.flexWrap = "wrap";

    // Combine scores for the half
    const team0Score = parseInt(match0.score.split("-")[0]) + parseInt(match1.score.split("-")[1]);
    const team1Score = parseInt(match0.score.split("-")[1]) + parseInt(match1.score.split("-")[0]);

    // Calculate top players for the half based on combined scores
    const topPlayers = { team0: { name: "", kills: 0, class: "" }, team1: { name: "", kills: 0, class: "" } };
    const playerStats = {};

    // Iterate over rounds in both matches to calculate stats
    [match0, match1].forEach((match) => {
      match.rounds.forEach((round) => {
        round.teams.forEach((team, i) => {
          const playerName = round.players[i];
          const playerClass = round.classes[i];

          if (!playerStats[playerName]) {
            playerStats[playerName] = { kills: 0, teamkills: 0, class: playerClass };
          }

          const kills = round.kills.filter((name) => name === playerName).length;
          const teamkills = round.teamkills.filter((name) => name === playerName).length;

          playerStats[playerName].kills += kills;
          playerStats[playerName].teamkills += teamkills;
        });
      });
    });

    Object.keys(playerStats).forEach((playerName) => {
      const total = playerStats[playerName].kills - playerStats[playerName].teamkills;
      const team = match0.rounds[0].teams[match0.rounds[0].players.indexOf(playerName)]; // Determine the team from match0

      if (team === 0 && total > topPlayers.team0.kills) {
        topPlayers.team0 = { name: playerName, kills: total, class: playerStats[playerName].class };
      } else if (team === 1 && total > topPlayers.team1.kills) {
        topPlayers.team1 = { name: playerName, kills: total, class: playerStats[playerName].class };
      }
    });

    // Render Team 0 (Left Side)
    const team0Div = document.createElement("div");
    team0Div.style.flex = "1";
    team0Div.style.textAlign = "center";
    team0Div.style.display = "flex";
    team0Div.style.flexDirection = "column";
    team0Div.style.flexWrap = "wrap";
    team0Div.style.alignItems = "center";
    team0Div.style.justifyContent = "flex-end";

    const team0Image = document.createElement("div");
      team0Image.style.textAlign = "center";
      team0Image.style.display = "flex";
      team0Image.style.flexDirection = "row";
      team0Image.style.flexWrap = "wrap";
      for(let i = 0; i < team0Score; i++){
        const fac1Img = document.createElement("img");
        const flag1 = facIcons[factions.indexOf(match0.faction_1)];
        const flag2 = facIcons[factions.indexOf(match0.faction_2)];
        fac1Img.src = `assets/img/${flag1}.png`;
        if (i > parseInt(match0.score.split("-")[0]-1)) fac1Img.src = `assets/img/${flag2}.png`;
        fac1Img.height = fac1Img.naturalHeight * 0.5;
        fac1Img.onload = () => {
          fac1Img.height = fac1Img.naturalHeight * 0.5;
        }
        fac1Img.style.display = "block";
        fac1Img.style.padding = "10px";
        fac1Img.style.margin = "0 auto";
        team0Image.appendChild(fac1Img);
      }
      team0Div.appendChild(team0Image);

    // Render classes from the last round of match0
    const team0Classes = document.createElement("div");
    team0Classes.style.marginTop = "10px";
    team0Classes.style.display = "flex";
    team0Classes.style.flexWrap = "wrap";
    team0Classes.style.justifyContent = "center";
    team0Classes.style.alignItems = "flex-end";
    

    match0.rounds[match0.rounds.length - 1].classes.forEach((className, i) => {
      if (match0.rounds[match0.rounds.length - 1].teams[i] === 0) {
        // Create a container for the class image and MVP star
        const classContainer = document.createElement("div");
        classContainer.style.position = "relative"; // Allows positioning of child elements
        classContainer.style.display = "inline-block"; // Keeps both elements together

        // Append the class image
        setClassImage(className, classContainer); // Assuming setClassImage returns an image element

        // Check if this player is the MVP
        if (i === match0.rounds[match0.rounds.length - 1].players.indexOf(topPlayers.team0.name)) {
          const team0mvp = document.createElement("img");
          team0mvp.src = "assets/img/mvp.png";
          team0mvp.style.position = "absolute"; 
          team0mvp.style.top = "-18px"; 
          team0mvp.style.left = "60%"; // inf is a little forward
          team0mvp.style.transform = "translateX(-50%)"; 
          classContainer.appendChild(team0mvp); 
        }

        team0Classes.appendChild(classContainer); // Append the container to the team classes div
      }
    });
    team0Div.appendChild(team0Classes);

    const team0Frag = document.createElement("div");
    team0Frag.style.marginTop = "10px";
    team0Frag.style.display = "flex";
    team0Frag.style.flexWrap = "wrap";
    team0Frag.style.justifyContent = "center";
    team0Frag.style.alignItems = "flex-end";
    team0Frag.textContent = topPlayers.team0.name + ` (${topPlayers.team0.kills} kills)`;
    team0Div.appendChild(team0Frag);

    // Render Team 1 (Right Side)
    const team1Div = document.createElement("div");
    team1Div.style.flex = "1";
    team1Div.style.textAlign = "center";
    team1Div.style.display = "flex";
    team1Div.style.flexDirection = "column";
    team1Div.style.alignItems = "center";
    team1Div.style.justifyContent = "flex-end";

    // Render faction flags for match1
    const team1Image = document.createElement("div");
    team1Image.style.textAlign = "center";
    team1Image.style.display = "flex";
    team1Image.style.flexDirection = "row";
    team1Image.style.flexWrap = "wrap";
    for (let i = 0; i < team1Score; i++) {
      const facImg = document.createElement("img");
      const flagImg = facIcons[factions.indexOf(match0.faction_2)];
      const flag2 = facIcons[factions.indexOf(match0.faction_1)];
      facImg.src = `assets/img/${flagImg}.png`;
      if (i > parseInt(match0.score.split(" - ")[1])-1) facImg.src = `assets/img/${flag2}.png`;
      facImg.height = facImg.naturalHeight * 0.5;
      facImg.onload = () => {
        facImg.height = facImg.naturalHeight * 0.5;
      }
      facImg.style.display = "block";
      facImg.style.padding = "10px";
      facImg.style.margin = "0 auto";
      team1Image.appendChild(facImg);
    }
    team1Div.appendChild(team1Image);


      // Class list images for Team 1
      const team1Classes = document.createElement("div");
      team1Classes.style.marginTop = "10px";
      team1Classes.style.display = "flex";
      team1Classes.style.flexWrap = "wrap";
      team1Classes.style.justifyContent = "center";
      team1Classes.style.alignItems = "flex-end";
      
      match0.rounds[match0.rounds.length - 1].classes.forEach((className, i) => {
      if (match0.rounds[match0.rounds.length - 1].teams[i] === 1) {
        // Create a container for the class image and MVP star
        const classContainer = document.createElement("div");
        classContainer.style.position = "relative"; // Allows positioning of child elements
        classContainer.style.display = "inline-block"; // Keeps both elements together

        // Append the class image
        setClassImage(className, classContainer, 1); // Assuming setClassImage returns an image element

        // Check if this player is the MVP
        if (i === match0.rounds[match0.rounds.length - 1].players.indexOf(topPlayers.team1.name)) {
          const team1mvp = document.createElement("img");
          team1mvp.src = "assets/img/mvp.png";
          team1mvp.style.position = "absolute"; 
          team1mvp.style.top = "-18px"; 
          team1mvp.style.left = "40%"; // inf is a little forward
          team1mvp.style.transform = "translateX(-50%)"; 
          classContainer.appendChild(team1mvp); 
        }

        team1Classes.appendChild(classContainer); // Append the container to the team classes div
      }
    });

      team1Div.appendChild(team1Classes);

    const team1Frag = document.createElement("div");
    team1Frag.style.marginTop = "10px";
    team1Frag.style.display = "flex";
    team1Frag.style.flexWrap = "wrap";
    team1Frag.style.justifyContent = "center";
    team1Frag.style.alignItems = "flex-end";
    team1Frag.textContent = topPlayers.team1.name + ` (${topPlayers.team1.kills} kills)`;
    team1Div.appendChild(team1Frag);

      // Center Section (Map and Score)
      const centerDiv = document.createElement("div");
      centerDiv.style.flex = "1";
      centerDiv.style.textAlign = "center";
      centerDiv.style.alignItems = "center";

      // Create a container for the thumbnail and text overlay
      const mapContainer = document.createElement("div");
      mapContainer.style.position = "relative"; // Enables positioning of text relative to the image
      mapContainer.style.display = "inline-block"; // Ensures proper layout

      // Map thumbnail image
      const mapThumbn = document.createElement("img");
      const thmbSrc = match0.map.toLowerCase().replaceAll(" ", "_").replaceAll("'","");

      mapThumbn.style.objectFit = "cover";
      mapThumbn.style.objectPosition = "center";
      mapThumbn.src = `assets/img/tbn_${thmbSrc}.png`
      mapThumbn.alt = "";
      
      // mapThumbn.style.width = "400px"; // Adjust width as needed
      // mapThumbn.style.height = "auto"; // Maintain aspect ratio
      mapContainer.appendChild(mapThumbn);

      // Map name text overlay
      const mapName = document.createElement("span");
      mapName.style.position = "absolute";
      mapName.style.top = "10px"; // Position near the top of the image
      mapName.style.left = "50%"; // Center horizontally
      mapName.style.transform = "translateX(-50%)"; // Align text to the center
      mapName.style.color = "white"; // Set text color for visibility
      mapName.style.fontWeight = "bold";
      mapName.style.fontSize = "32px"; // Adjust font size as needed
      mapName.style.textShadow = "2px 2px 4px rgba(0, 0, 0, 0.7)"; // Add text shadow for readability
      mapName.style.whiteSpace = "nowrap"; 
      mapName.textContent = match0.map;
      mapContainer.appendChild(mapName);

      // Score with flag icons overlay
      const scoreContainer = document.createElement("div");
      scoreContainer.style.position = "absolute"; // Overlay on top of the image
      scoreContainer.style.top = "75%"; // C
      scoreContainer.style.left = "50%"; // Center horizontally
      scoreContainer.style.transform = "translate(-50%, -50%)"; // Offset for perfect centering
      scoreContainer.style.display = "flex";
      scoreContainer.style.alignItems = "center";
      scoreContainer.style.justifyContent = "center";
      scoreContainer.style.gap = "10px"; // Space between elements

      // Flag 1 (Team 0)
      const fac1Img = document.createElement("img");
      const flag1 = facIcons[factions.indexOf(match0.faction_1)];
      fac1Img.src = `assets/img/${flag1}.png`;
      fac1Img.height = fac1Img.naturalHeight * 0.35;
      fac1Img.onload = () => {
        fac1Img.height = fac1Img.naturalHeight * 0.35;
      }
      scoreContainer.appendChild(fac1Img);

      // Score Text
      const scoreDiv = document.createElement("span");
      scoreDiv.style.fontSize = "32px"; // Adjust font size as needed
      scoreDiv.style.fontWeight = "bold";
      scoreDiv.style.color = "white"; // Ensure it stands out on the image
      scoreDiv.style.textShadow = "2px 2px 4px rgba(0, 0, 0, 0.7)"; // Add shadow for readability
      scoreDiv.textContent = `${team0Score} - ${team1Score}`;
      scoreContainer.appendChild(scoreDiv);

      // Flag 2 (Team 1)
      const fac2Img = document.createElement("img");
      const flag2 = facIcons[factions.indexOf(match0.faction_2)];
      fac2Img.src = `assets/img/${flag2}.png`;
      fac2Img.height = fac2Img.naturalHeight * 0.35;
      fac2Img.onload = () => {
        fac2Img.height = fac2Img.naturalHeight * 0.35;
      }
      scoreContainer.appendChild(fac2Img);

      // Add the scoreContainer to the mapContainer (or centerDiv if preferred)
      mapContainer.appendChild(scoreContainer);

      //numbering half list to help orient a bit 
      const pickupName = document.createElement("div");
      pickupName.style.marginBottom = "10px";
      pickupName.textContent = `#${halves.length - 24 - reversedIndex}`;
      centerDiv.appendChild(pickupName);

      // Append the container to the center div
      centerDiv.appendChild(mapContainer);


    // Append to the container
    halfDiv.appendChild(team0Div);
    halfDiv.appendChild(centerDiv);
    halfDiv.appendChild(team1Div);
    
    halfDiv.addEventListener("click", () => {
        updateURLToHalf(ogindex);
      });

    container.appendChild(halfDiv);
  });
  
  //console.log("FIRSTPICKUP", halfs[startingIndex][0], partyFirstMatch);
  pickupMatches.push([halfs[startingIndex][0], partyFirstMatch]);
  //pickupParties++
  for(let i=0; i<pickupParties; i++){
    const pickupTile = document.getElementById(`pickup-${i}`);
    pickupTile.textContent = `PICKUP PARTY #${pickupParties - i}`;
    pickupTile.addEventListener("click", () => {
        renderLandingPage("players")
        renderPlayersList(pickupMatches[i][0], pickupMatches[i][1], `PICKUP PARTY #${pickupParties - i}`)
      });
  }
}

function setClassImage(usedclass, targetElement, flip) {
  let type = null;

  if (infClasses.some(className => usedclass.includes(className))) {
    type = "inf";
  } else if (cavClasses.some(className => usedclass.includes(className))) {
    type = "cav";
  } else if (arcClasses.some(className => usedclass.includes(className))) {
    type = "arc";
  }

  if (type) {
    const classImage = document.createElement("img");
    classImage.src = `assets/img/class_${type}.png`;
    classImage.height = classImage.naturalHeight * 0.5;
    classImage.onload = () => {
      classImage.height = classImage.naturalHeight * 0.5;
    }
    if (flip) classImage.style.transform = "scaleX(-1)";
    classImage.style.paddingLeft = "8px";
    //classImage.style.verticalAlign = "middle"; // Align image vertically with content
    targetElement.appendChild(classImage);
  }
}

  window.addEventListener("popstate", (event) => {
  const state = event.state;
  if (state) {
    if (state.tab) {
      // User navigated to a tab
      renderLandingPage(state.tab);
      // Restore the scroll position if saved
      const tabContentContainer = document.getElementById("tab-content");
      if (tabContentContainer && scrollPositions[state.tab]) {
        tabContentContainer.scrollTop = scrollPositions[state.tab];
      }
    } else if (state.bracket) {
      // User navigated to a match
      renderBracketList(tournaments[state.bracket]);
    } else if (state.match) {
      // User navigated to a match
      renderMatchDetails(state.match);
    }
  } else {
    // Handle the base case (no state) â€“ go to the default tab
    renderLandingPage("home"); 
    handleURLChange();
  }
});
function handleURLChange() {
  const params = new URLSearchParams(window.location.search);

  // Handle "tab" parameter
  const tabStr = params.get("tab");
  if (tabStr !== null) {
    renderLandingPage(tabStr); // Render the tab specified in the URL
    return;
  }


// Handle "player" parameter
const playerStr = params.get("player");
if (playerStr !== null) {
  //const playerId = parseInt(playerStr, 10);
  //if (!isNaN(playerId)) {
    renderPlayerDetails(playerStr);
    return;
  //}
}

// Handle "bracket" parameter
const bracketStr = params.get("bracket");
if (bracketStr !== null) {
  const body = document.body;
  const bracketId = parseInt(bracketStr, 10);
  if (bracketId == 1)body.style.backgroundImage = "url('assets/img/mb5.png')";
  if (!isNaN(bracketId) && tournaments[bracketId]) {
    renderBracketList(tournaments[bracketId]);
    return;
  }
}

// Handle "scrim" parameter
const scrimStr = params.get("scrim");
if (scrimStr !== null) {
  const scrimId = parseInt(scrimStr, 10);
  if (!isNaN(scrimId) && scrims[scrimId]) {
    renderScrim(scrims[scrimId]);
    return;
  }
}

  // Handle "half" parameter
  const halfStr = params.get("half");
  if (halfStr !== null) {
    const halfId = parseInt(halfStr, 10);
    if (!isNaN(halfId) && halfs[halfId]) {
      renderHalf(halfs[halfId]);
      return;
    }
  }

  // Handle "match" and "round" parameters
  const matchStr = params.get("match");
  const roundStr = params.get("round");
  if (matchStr !== null) {
    const matchId = parseInt(matchStr, 10);
    if (!isNaN(matchId) && matches[matchId]) {
      if (roundStr !== null) {
        const roundId = parseInt(roundStr, 10);
        if (!isNaN(roundId) && matches[matchId].rounds[roundId] !== undefined) {
          renderSingleRound(matchId, roundId, 0); // Render the specific round
          return;
        }
      }
      renderMatchDetails(matchId, 0); // Render the match details
      return;
    }
  }
  const gfStr = params.get("gf");
  if (gfStr !== null) {
    const gfId = parseInt(gfStr, 10);
    if (!isNaN(gfId) && groupfights[gfId]) {
      if (roundStr !== null) {
        const roundId = parseInt(roundStr, 10);
        if (!isNaN(roundId) && groupfights[gfId].rounds[roundId] !== undefined) {
          renderSingleRound(gfId, roundId, 1); // Render the specific round
          return;
        }
      }
      renderMatchDetails(gfId, 1); // Render the match details
      return;
    }
  }

  // Default to rendering the "bracket" tab if no parameters are found
  renderLandingPage("home");
  //handleURLChange();
}

//tournament bracket page
function updateURLToBracket(tournID) {
    const url = new URL(window.location.href);
    // Remove scrim and half parameters if present.
    url.searchParams.delete("scrim");
    url.searchParams.delete("half");
    url.searchParams.delete("match");
    url.searchParams.delete("player");
    url.searchParams.set("bracket", tournID);
    
    const baseUrl = window.location.origin + window.location.pathname;

    window.history.pushState({ bracket: tournID }, "", `${baseUrl}?bracket=${tournID}`);
    renderBracketList(tournaments[tournID]);
  }

  // Update the URL to show a match view (with optional round view).
  function updateURLToPlayer(playerID) {
    const url = new URL(window.location.href);
    // Remove scrim and half parameters if present.
    url.searchParams.delete("scrim");
    url.searchParams.delete("half");
    url.searchParams.set("player", playerID);
    
    const baseUrl = window.location.origin + window.location.pathname;

      //if (!window.history.state || window.history.state.player !== playerID) {
        window.history.pushState({ player: playerID }, "", `${baseUrl}?player=${playerID}`);
    //}
    renderPlayerDetails(playerID);
  }

  // Update the URL to show a match view (with optional round view).
  function updateURLToGFMatch(matchId, roundId) {
    const url = new URL(window.location.href);
    // Remove scrim and half parameters if present.
    url.searchParams.delete("scrim");
    url.searchParams.delete("half");
    url.searchParams.delete("match");
    url.searchParams.set("gf", matchId);
    if (roundId !== undefined) {
      url.searchParams.set("round", roundId);
    } else {
      url.searchParams.delete("round");
    } 
    
    const baseUrl = window.location.origin + window.location.pathname;

    if (roundId !== undefined) {
      renderSingleRound(matchId, roundId, 1);
      //window.history.pushState({ match: matchId }, "", `${baseUrl}?match=${matchId}&round=${roundId}`);
    } else {
      renderMatchDetails(matchId, 1);
      if (!window.history.state || window.history.state.match !== matchId) {
        window.history.pushState({ gf: matchId }, "", `${baseUrl}?gf=${matchId}`);
      }
    }
  }
  // Update the URL to show a match view (with optional round view).
  function updateURLToMatch(matchId, roundId) {
    const url = new URL(window.location.href);
    // Remove scrim and half parameters if present.
    url.searchParams.delete("scrim");
    url.searchParams.delete("half");
    url.searchParams.set("match", matchId);
    if (roundId !== undefined) {
      url.searchParams.set("round", roundId);
    } else {
      url.searchParams.delete("round");
    } 
    
    const baseUrl = window.location.origin + window.location.pathname;

    if (roundId !== undefined) {
      renderSingleRound(matchId, roundId, 0);
      //window.history.pushState({ match: matchId }, "", `${baseUrl}?match=${matchId}&round=${roundId}`);
    } else {
      renderMatchDetails(matchId, 0);
      if (!window.history.state || window.history.state.match !== matchId) {
        window.history.pushState({ match: matchId }, "", `${baseUrl}?match=${matchId}`);
      }
    }
  }

  // Update the URL to show a half view.
  function updateURLToHalf(halfId) {
    const url = new URL(window.location.href);
    // Remove scrim, match and round parameters.
    url.searchParams.delete("scrim");
    url.searchParams.delete("match");
    url.searchParams.delete("round");
    url.searchParams.set("half", halfId);
    
    if(halfs[halfId][1] === -1 || halfs[halfId][1] === 43) {

      //history.replaceState(null, document.title, window.location.href);
      updateURLToMatch(halfs[halfId][0]);
      return;
    } else {
      const baseUrl = window.location.origin + window.location.pathname;
      window.history.pushState({ half: halfId }, "", `${baseUrl}?half=${halfId}`);
      renderHalf(halfs[halfId]);

    }
  }

  // Update the URL to show a scrim view.
  function updateURLToScrim(scrimId) {
    const url = new URL(window.location.href);
    // Remove half, match, and round parameters.
    url.searchParams.delete("half");
    url.searchParams.delete("match");
    url.searchParams.delete("round");
    url.searchParams.set("scrim", scrimId);
    if(scrims[scrimId][1] === -1) {
      //history.replaceState(null, document.title, window.location.href);
      updateURLToHalf(scrims[scrimId][0]);
      return;
    } else {
    const baseUrl = window.location.origin + window.location.pathname;
    window.history.pushState({ scrim: scrimId }, "", `${baseUrl}?scrim=${scrimId}`);
    renderScrim(scrims[scrimId]);

    }
  }

  // Update the URL to clear all view state and display the landing page.
  function updateURLToLanding() {
    const url = new URL(window.location.href);
    url.searchParams.delete("bracket");
    url.searchParams.delete("scrim");
    url.searchParams.delete("half");
    url.searchParams.delete("match");
    url.searchParams.delete("round");
    window.history.pushState(null, '', url.toString());
    //renderLandingPage("bracket");
  }
// Hook into browser navigation (Back/Forward)
//window.addEventListener('popstate', handleURLChange);

  // And call handleURLChange() on initial load.
  //handleURLChange();

  // Fetch matches data and initialize
  let matches = []; // Global storage for matches data
  let groupfights = []; // Global storage for matches data
  let teams = [];
  let playerIds = [];
  let playerNames = [];Promise.all([
    fetch('allplayers.json').then(response => {
        if (!response.ok) {
            throw new Error("Failed to load allplayers.json");
        }
        return response.json();
    }),
    fetch('allmatches.json').then(response => {
        if (!response.ok) {
            throw new Error("Failed to load allmatches.json");
        }
        return response.json();
    }),
    fetch('groupfights.json').then(response => {
        if (!response.ok) {
            throw new Error("Failed to load groupfights.json");
        }
        return response.json();
    })
])
    .then(([allPlayersData, allMatchesData, groupFightsData]) => {
        // Process allPlayers.json
        playerIds = allPlayersData.player_ids;
        playerNames = allPlayersData.player_names;
        //console.log(playerIds, playerNames);
        if (!playerIds || !playerNames) {
            document.getElementById('content').innerHTML = "No player data available.";
            return;
        }

        // Process allmatches.json
        matches = allMatchesData.matches;
        fillHalfsList();

        // Process groupfights.json
        groupfights = groupFightsData.matches;

        // Call handleURLChange after all data is processed
        handleURLChange();
        window.addEventListener('popstate', handleURLChange);
    })
    .catch(error => {
        console.error("Error loading data:", error);
        document.getElementById('content').innerHTML = `<p style="color: red;">Failed to load data. Please try again later.</p>`;
    });

function calculateTotalStats(match) {
    // 1. Aggregate cumulative stats over all rounds.
    //    getPlayerStats() should work whether match.rounds is an array or single round.
    const aggregatedStats = getPlayerStats(match.rounds); 

    // 2. Split the aggregated stats into team 0 and team 1 and sort each by kills.
    const { team0, team1 } = splitAndSortByTeam(aggregatedStats);

    // 3. Compute overall match score based on round results.
    //    (For example, per your earlier logic: a round with "Team 2 win" adds to team0â€™s score,
    //     and "Team 1 win" adds to team1â€™s score.)

    //ruthven - SO turns out, Flag wins use Team 0 == 1 and Team 1 == 0
    //NON flag wins use Team 0 == 2 and Team 1 == 1 
    //WHYHYWHWYHWYYYYY
    let team0Score = 0;
    let team1Score = 0;
    match.rounds.forEach(round => {
        if (round.result.includes("Team 2 win")) {
          if (round.result.includes("flag"))
            {team1Score++} else {team0Score++};
        } else if (round.result.includes("Team 1 win")) {
          if (round.result.includes("flag"))
            {team0Score++} else {team1Score++};
        }
    });

    // 4. Build a container for the stats, and create a flex wrapper to display two tables side by side.
    const statsContainer = document.createElement("div");
    statsContainer.className = "stats-container";  // Use your pre-defined CSS

    const tableWrapper = document.createElement("div");
    tableWrapper.id = "tables-container"; 
    tableWrapper.className = "table-wrapper";  // This should style the tables side by side with padding/gap

    // 5. Generate each teamâ€™s table using our helper (which applies common styling).
    //    For team 0, display the faction name from match.faction_1 and team0â€™s overall score.
    const team0Table = generateTeamTableCommon(team0, match.faction_1, 1);
    //    Similarly for team 1 using match.faction_2.
    const team1Table = generateTeamTableCommon(team1, match.faction_2, 1);

    // 6. Append the generated tables to the wrapper and then to the stats container.
    tableWrapper.appendChild(team0Table);
    tableWrapper.appendChild(team1Table);
    statsContainer.appendChild(tableWrapper);

    // 7. Finally, append the stats container to the content area.
    const tabContentDiv = document.getElementById("tab-content");
    tabContentDiv.appendChild(statsContainer);
    adjustTableLayout();
}
  // Helper: Flip the team assignments for a round.
  function flipRound(round) {
    // Create a shallow copy of arrays; note that primitive arrays like team assignments can be mapped.
    return {
      players: round.players.slice(),
      // Flip team: 0 becomes 1, 1 becomes 0.
      teams: round.teams.map(team => (team === 0 ? 1 : 0)),
      kills: round.kills.slice(),
      deaths: round.deaths.slice(),
      assists: round.assists.slice(),
      dmg: round.dmg.slice(),
      teamkills: round.teamkills.slice(),
      tdmg: round.tdmg.slice(),
      classes: round.classes.slice(),
      result: round.result // leave as-is
    };
  }


  /**
   * Render half view.
   *
   * @param {Array} halfIndices - Array of two match indices, e.g. [0,1].
   *
   * For the first match (index 0 in halfIndices) we use rounds as-is,
   * for the second match (index 1) we flip each round's teams.
   * Also, we flip the scoring logic for rounds coming from the second match.
   */
  function renderHalf(halfIndices) {
    
    
    // if (!window.history.state || window.history.state.tab !== tab) {
    //   const baseUrl = window.location.origin + window.location.pathname;
    //   window.history.pushState({ half: halfId }, "", `${baseUrl}?half=${halfId}`);
    // }
    let combinedRounds = [];
    // Compute overall scores for the half.
    let team0Score = 0;
    let team1Score = 0;
    let m1team0Score = 0;
    let m1team1Score = 0;
    let m2team0Score = 0;
    let m2team1Score = 0;
    
    const body = document.body;
    body.style.backgroundRepeat = "no-repeat"; 
    body.style.backgroundPosition = "center center"; 
    body.style.backgroundAttachment = "fixed"; 
    body.style.backgroundSize = "cover"; 
    
    const bgSrc = matches[halfIndices[0]].map.toLowerCase().replaceAll(" ", "_").replaceAll("'","");
    if (bgSrc == -1){
      body.style.backgroundImage = `url('assets/img/mb2.png')`;

    } else {
      body.style.backgroundImage = `url('assets/img/bg_${bgSrc}.png')`;

    }

    halfIndices.forEach((mIndex, i) => {
      const matchObj = matches[mIndex];
      if (matchObj && matchObj.rounds) {
        matchObj.rounds.forEach(round => {
          // For the second match, flip the round.
          const processedRound = (i === 1) ? flipRound(round) : round;
          combinedRounds.push(processedRound);
          
          // Score logic: For match index 0 (first match), use normal logic:
          // if round.result includes "Team 2 win" then team0 wins,
          // if includes "Team 1 win" then team1 wins.
          // For match index 1 (second match), the roles are swapped.
          if (i === 0) {
            if (round.result.includes("Team 2 win")) {
              if (round.result.includes("flag"))
                {
                  team1Score++
                  m1team1Score++
                } else {
                  team0Score++
                  m1team0Score++
                };
            } else if (round.result.includes("Team 1 win")) {
              if (round.result.includes("flag"))
                {
                  team0Score++
                  m1team0Score++
                } else {
                  team1Score++
                  m1team1Score++

                };
            }
          } else {
            if (round.result.includes("Team 2 win")) {
              if (round.result.includes("flag"))
                {
                  team0Score++
                  m2team0Score++
                } else {
                  team1Score++
                  m2team1Score++
                };
            } else if (round.result.includes("Team 1 win")) {
              if (round.result.includes("flag"))
                {
                  team1Score++
                  m2team1Score++
                } else {
                  team0Score++
                  m2team0Score++
                };
            }
          }
        });
      }
    });

    // Now aggregate stats from all combined rounds.
    const aggregatedStats = getPlayerStats(combinedRounds);
    const { team0, team1 } = splitAndSortByTeam(aggregatedStats);

    // Render the half view.
    const contentDiv = document.getElementById("content");
    contentDiv.classList.remove("bracket");
    contentDiv.classList.remove("landing");
    contentDiv.classList.add("match-detail");
    contentDiv.innerHTML = ""; // Clear previous content
    renderTabBar(contentDiv, "matches");
    const tabContentContainer = document.createElement("div");
    tabContentContainer.id = "tab-content";
    tabContentContainer.style.marginTop = "20px";

    // // Add a "Back to Matches" button.
    // const backButton = document.createElement("button");
    // backButton.textContent = "Back to Matches";
    // backButton.style.marginBottom = "20px";
    // backButton.onclick = updateURLToLanding;
    // contentDiv.appendChild(backButton);

    // Fetch map and match details
    const match1Info = matches[halfIndices[0]];
    const match2Info = matches[halfIndices[1]];
    
    const halfHeaderContainer = document.createElement("div");
    halfHeaderContainer.style.display = "flex";
    halfHeaderContainer.style.flexDirection = "column";
    halfHeaderContainer.style.alignItems = "center";

    // Row for Half 1:
    const half1Row = document.createElement("div");
    half1Row.style.margin = "0px";
    half1Row.style.display = "flex";
    half1Row.style.width = "100%";
    half1Row.style.justifyContent = "space-between";
    half1Row.style.alignItems = "center";
    // Create five flex cells (each 20% width)
    const half1Team0ScoreDiv = document.createElement("h1");
    half1Team0ScoreDiv.style.flex = "1";
    half1Team0ScoreDiv.style.textAlign = "right";
    half1Team0ScoreDiv.textContent = m1team0Score;

    const half1Faction1Div = document.createElement("h2");
    const fac11Img = document.createElement("img");
    const flag11 = facIcons[factions.indexOf(match1Info.faction_1)];
    fac11Img.src = `assets/img/${flag11}.png`;
    fac11Img.style.margin = "0px";
    half1Faction1Div.appendChild(fac11Img);
    half1Faction1Div.style.flex = "1";
    half1Faction1Div.style.textAlign = "center";
    //half1Faction1Div.textContent = half1Info.faction_1;

    const half1MapDiv = document.createElement("h1");
    half1MapDiv.style.flex = "1";
    half1MapDiv.style.textAlign = "center";
    half1MapDiv.textContent = match1Info.map + " Set 1";

    const half1Faction2Div = document.createElement("h2");
    const fac12Img = document.createElement("img");
    const flag12 = facIcons[factions.indexOf(match1Info.faction_2)];
    fac12Img.src = `assets/img/${flag12}.png`;
    fac12Img.style.margin = "0px";
    half1Faction2Div.appendChild(fac12Img);
    half1Faction2Div.style.flex = "1";
    half1Faction2Div.style.textAlign = "center";
    //half1Faction2Div.textContent = half1Info.faction_2;

    const half1Team1ScoreDiv = document.createElement("h1");
    half1Team1ScoreDiv.style.flex = "1";
    half1Team1ScoreDiv.style.textAlign = "left";
    half1Team1ScoreDiv.textContent = m1team1Score;

    // Make the entire row clickable:
    half1Row.style.cursor = "pointer";
    half1Row.onclick = () => {
        updateURLToMatch(halfIndices[0])
    };

    half1Row.appendChild(half1Team0ScoreDiv);
    half1Row.appendChild(half1Faction1Div);
    half1Row.appendChild(half1MapDiv);
    half1Row.appendChild(half1Faction2Div);
    half1Row.appendChild(half1Team1ScoreDiv);

// Row for Half 2:
const half2Row = document.createElement("div");
half2Row.style.display = "flex";
half2Row.style.width = "100%";
half2Row.style.justifyContent = "space-between";
half2Row.style.alignItems = "center";

const half2Team0ScoreDiv = document.createElement("h1");
half2Team0ScoreDiv.style.flex = "1";
half2Team0ScoreDiv.style.textAlign = "right";
half2Team0ScoreDiv.textContent = m2team0Score;

const half2Faction1Div = document.createElement("h2");
const fac21Img = document.createElement("img");
const flag21 = facIcons[factions.indexOf(match2Info.faction_2)];
fac21Img.src = `assets/img/${flag21}.png`;
fac21Img.style.margin = "0px";
half2Faction1Div.appendChild(fac21Img);
half2Faction1Div.style.flex = "1";
half2Faction1Div.style.textAlign = "center";
// half2Faction1Div.textContent = 

const half2MapDiv = document.createElement("h1");
half2MapDiv.style.flex = "1";
half2MapDiv.style.textAlign = "center";
half2MapDiv.textContent = match2Info.map + " Set 2";

const half2Faction2Div = document.createElement("h2");
const fac22Img = document.createElement("img");
const flag22 = facIcons[factions.indexOf(match2Info.faction_1)];
fac22Img.src = `assets/img/${flag22}.png`;
fac22Img.style.margin = "0px";
half2Faction2Div.appendChild(fac22Img);
half2Faction2Div.style.flex = "1";
half2Faction2Div.style.textAlign = "center";

// half2Faction2Div.textContent = half2Info.faction_2;

const half2Team1ScoreDiv = document.createElement("h1");
half2Team1ScoreDiv.style.flex = "1";
half2Team1ScoreDiv.style.textAlign = "left";
half2Team1ScoreDiv.textContent = m2team1Score;

half2Row.style.cursor = "pointer";
half2Row.onclick = () => {
   updateURLToMatch(halfIndices[1])
};

half2Row.appendChild(half2Team0ScoreDiv);
half2Row.appendChild(half2Faction1Div);
half2Row.appendChild(half2MapDiv);
half2Row.appendChild(half2Faction2Div);
half2Row.appendChild(half2Team1ScoreDiv);

// Append both rows to the container:
halfHeaderContainer.appendChild(half1Row);
halfHeaderContainer.appendChild(half2Row);
    
    // Total score
    const totalTeam0Score = match1Info.team0Score + match2Info.team0Score;
    const totalTeam1Score = match1Info.team1Score + match2Info.team1Score;

    const totalScore = document.createElement("h1");
    totalScore.style.margin = "0px";
    totalScore.style.fontSize = "2em";
    totalScore.style.fontWeight = "bold";
    totalScore.textContent = `${team0Score} - ${team1Score}`;
    halfHeaderContainer.appendChild(totalScore);

    // Add everything to the main content div
    tabContentContainer.appendChild(halfHeaderContainer);
    // Create a table wrapper for sideâ€“byâ€“side tables.
    const tableWrapper = document.createElement("div");
    tableWrapper.className = "table-wrapper";
    tableWrapper.id = "tables-container"; 
    tableWrapper.style.display = "flex";
    //tableWrapper.style.gap = "150px";

    // Since in a half, the two matches swap teams, the aggregated teams now are:
    // - team0 in the aggregated stats consists of match0's team0 and match1's flipped team1.
    // - team1 from aggregated stats is match0's team1 and match1's flipped team0.
    // We assume the faction names remain constant (from the first match).
    const faction0 = matches[halfIndices[0]].faction_1;
    const faction1 = matches[halfIndices[0]].faction_2;

    const statsContainer = document.createElement("div");
    statsContainer.className = "stats-container";  // Use your pre-defined CSS

    tableWrapper.appendChild(generateTeamTableCommon(team0, faction0));
    tableWrapper.appendChild(generateTeamTableCommon(team1, faction1));

    // Append the tables to the content.
    statsContainer.appendChild(tableWrapper);
    tabContentContainer.appendChild(statsContainer);
    contentDiv.appendChild(tabContentContainer);
    adjustTableLayout();
  }


    </script>
    </body>
</html>
